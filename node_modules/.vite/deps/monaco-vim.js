import {
  editor_api_exports,
  init_editor_api,
  init_shiftCommand,
  shiftCommand_exports
} from "./chunk-LI3KAPE2.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-LK32TJAX.js";

// node_modules/monaco-vim/lib/cm_adapter.js
var require_cm_adapter = __commonJS({
  "node_modules/monaco-vim/lib/cm_adapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _editor = (init_editor_api(), __toCommonJS(editor_api_exports));
    var _shiftCommand = (init_shiftCommand(), __toCommonJS(shiftCommand_exports));
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var VerticalRevealType = {
      Bottom: 4
    };
    var EditorOptConstants = {
      readOnly: 65,
      cursorWidth: 20,
      fontInfo: 32
    };
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch) {
      return /\w/.test(ch) || ch > "Â€" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    }
    function Pos(line, column) {
      if (!(this instanceof Pos)) {
        return new Pos(line, column);
      }
      this.line = line;
      this.ch = column;
    }
    function signal(cm, signal2, args) {
      cm.dispatch(signal2, args);
    }
    function dummy(key) {
      return function() {
      };
    }
    var doFold;
    var noFold;
    if (String.prototype.normalize) {
      doFold = function doFold2(str) {
        return str.normalize("NFD").toLowerCase();
      };
      noFold = function noFold2(str) {
        return str.normalize("NFD");
      };
    } else {
      doFold = function doFold2(str) {
        return str.toLowerCase();
      };
      noFold = function noFold2(str) {
        return str;
      };
    }
    var StringStream = function StringStream2(string, tabSize) {
      this.pos = this.start = 0;
      this.string = string;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
    };
    StringStream.prototype = {
      eol: function eol() {
        return this.pos >= this.string.length;
      },
      sol: function sol() {
        return this.pos == this.lineStart;
      },
      peek: function peek() {
        return this.string.charAt(this.pos) || void 0;
      },
      next: function next() {
        if (this.pos < this.string.length) return this.string.charAt(this.pos++);
      },
      eat: function eat(match) {
        var ch = this.string.charAt(this.pos);
        if (typeof match == "string") var ok = ch == match;
        else var ok = ch && (match.test ? match.test(ch) : match(ch));
        if (ok) {
          ++this.pos;
          return ch;
        }
      },
      eatWhile: function eatWhile(match) {
        var start = this.pos;
        while (this.eat(match)) {
        }
        return this.pos > start;
      },
      eatSpace: function eatSpace() {
        var start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
        return this.pos > start;
      },
      skipToEnd: function skipToEnd() {
        this.pos = this.string.length;
      },
      skipTo: function skipTo(ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
          this.pos = found;
          return true;
        }
      },
      backUp: function backUp(n) {
        this.pos -= n;
      },
      column: function column() {
        throw "not implemented";
      },
      indentation: function indentation() {
        throw "not implemented";
      },
      match: function match(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function cased2(str) {
            return caseInsensitive ? str.toLowerCase() : str;
          };
          var substr = this.string.substr(this.pos, pattern.length);
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) this.pos += pattern.length;
            return true;
          }
        } else {
          var match2 = this.string.slice(this.pos).match(pattern);
          if (match2 && match2.index > 0) return null;
          if (match2 && consume !== false) this.pos += match2[0].length;
          return match2;
        }
      },
      current: function current() {
        return this.string.slice(this.start, this.pos);
      },
      hideFirstChars: function hideFirstChars(n, inner) {
        this.lineStart += n;
        try {
          return inner();
        } finally {
          this.lineStart -= n;
        }
      }
    };
    function toCmPos(pos) {
      return new Pos(pos.lineNumber - 1, pos.column - 1);
    }
    function toMonacoPos(pos) {
      return new _editor.Position(pos.line + 1, pos.ch + 1);
    }
    var Marker = function() {
      function Marker2(cm, id, line, ch) {
        _classCallCheck(this, Marker2);
        this.cm = cm;
        this.id = id;
        this.lineNumber = line + 1;
        this.column = ch + 1;
        cm.marks[this.id] = this;
      }
      return _createClass(Marker2, [{
        key: "clear",
        value: function clear() {
          delete this.cm.marks[this.id];
        }
      }, {
        key: "find",
        value: function find() {
          return toCmPos(this);
        }
      }]);
    }();
    function monacoToCmKey(e) {
      var skip = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var addQuotes = true;
      var keyName = _editor.KeyCode[e.keyCode];
      if (e.key) {
        keyName = e.key;
        addQuotes = false;
      }
      var key = keyName;
      var skipOnlyShiftCheck = skip;
      switch (e.keyCode) {
        case _editor.KeyCode.Shift:
        case _editor.KeyCode.Meta:
        case _editor.KeyCode.Alt:
        case _editor.KeyCode.Ctrl:
          return key;
        case _editor.KeyCode.Escape:
          skipOnlyShiftCheck = true;
          key = "Esc";
          break;
        case _editor.KeyCode.Space:
          skipOnlyShiftCheck = true;
          break;
      }
      if (keyName.startsWith("Key") || keyName.startsWith("KEY_")) {
        key = keyName[keyName.length - 1].toLowerCase();
      } else if (keyName.startsWith("Digit")) {
        key = keyName.slice(5, 6);
      } else if (keyName.startsWith("Numpad")) {
        key = keyName.slice(6, 7);
      } else if (keyName.endsWith("Arrow")) {
        skipOnlyShiftCheck = true;
        key = keyName.substring(0, keyName.length - 5);
      } else if (keyName.startsWith("US_") || // `Bracket` check for monaco >= 0.30.0
      keyName.startsWith("Bracket") || !key) {
        key = e.browserEvent.key;
      }
      if (!skipOnlyShiftCheck && !e.altKey && !e.ctrlKey && !e.metaKey) {
        key = e.key || e.browserEvent.key;
      } else {
        if (e.altKey) {
          key = "Alt-".concat(key);
        }
        if (e.ctrlKey) {
          key = "Ctrl-".concat(key);
        }
        if (e.metaKey) {
          key = "Meta-".concat(key);
        }
        if (e.shiftKey) {
          key = "Shift-".concat(key);
        }
      }
      if (key.length === 1 && addQuotes) {
        key = "'".concat(key, "'");
      }
      return key;
    }
    var CMAdapter = function() {
      function CMAdapter2(editor) {
        _classCallCheck(this, CMAdapter2);
        _initialiseProps.call(this);
        this.editor = editor;
        this.state = {
          keyMap: "vim"
        };
        this.marks = {};
        this.$uid = 0;
        this.disposables = [];
        this.listeners = {};
        this.curOp = {};
        this.attached = false;
        this.statusBar = null;
        this.options = {};
        this.addLocalListeners();
        this.ctxInsert = this.editor.createContextKey("insertMode", true);
      }
      return _createClass(CMAdapter2, [{
        key: "attach",
        value: function attach() {
          CMAdapter2.keyMap.vim.attach(this);
        }
      }, {
        key: "addLocalListeners",
        value: function addLocalListeners() {
          this.disposables.push(this.editor.onDidChangeCursorPosition(this.handleCursorChange), this.editor.onDidChangeModelContent(this.handleChange), this.editor.onKeyDown(this.handleKeyDown));
        }
      }, {
        key: "handleReplaceMode",
        value: function handleReplaceMode(key, e) {
          var fromReplace = false;
          var _char = key;
          var pos = this.editor.getPosition();
          var range = new _editor.Range(pos.lineNumber, pos.column, pos.lineNumber, pos.column + 1);
          var forceMoveMarkers = true;
          if (key.startsWith("'")) {
            _char = key[1];
          } else if (_char === "Enter") {
            _char = "\n";
          } else if (_char === "Backspace") {
            var lastItem = this.replaceStack.pop();
            if (!lastItem) {
              return;
            }
            fromReplace = true;
            _char = lastItem;
            range = new _editor.Range(pos.lineNumber, pos.column, pos.lineNumber, pos.column - 1);
          } else {
            return;
          }
          e.preventDefault();
          e.stopPropagation();
          if (!this.replaceStack) {
            this.replaceStack = [];
          }
          if (!fromReplace) {
            this.replaceStack.push(this.editor.getModel().getValueInRange(range));
          }
          this.editor.executeEdits("vim", [{
            text: _char,
            range,
            forceMoveMarkers
          }]);
          if (fromReplace) {
            this.editor.setPosition(range.getStartPosition());
          }
        }
      }, {
        key: "setOption",
        value: function setOption(key, value) {
          this.state[key] = value;
          if (key === "theme") {
            _editor.editor.setTheme(value);
          }
        }
      }, {
        key: "getConfiguration",
        value: function getConfiguration() {
          var editor = this.editor;
          var opts = EditorOptConstants;
          if (typeof editor.getConfiguration === "function") {
            return editor.getConfiguration();
          } else if ("EditorOption" in _editor.editor) {
            opts = _editor.editor.EditorOption;
          }
          return {
            readOnly: editor.getOption(opts.readOnly),
            viewInfo: {
              cursorWidth: editor.getOption(opts.cursorWidth)
            },
            fontInfo: editor.getOption(opts.fontInfo)
          };
        }
      }, {
        key: "getOption",
        value: function getOption(key) {
          if (key === "readOnly") {
            return this.getConfiguration().readOnly;
          } else if (key === "firstLineNumber") {
            return this.firstLine() + 1;
          } else if (key === "indentWithTabs") {
            return !this.editor.getModel().getOptions().insertSpaces;
          } else {
            if (typeof this.editor.getConfiguration === "function") {
              return this.editor.getRawConfiguration()[key];
            }
            return this.editor.getRawOptions()[key];
          }
        }
      }, {
        key: "dispatch",
        value: function dispatch(signal2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var listeners = this.listeners[signal2];
          if (!listeners) {
            return;
          }
          listeners.forEach(function(handler) {
            return handler.apply(void 0, args);
          });
        }
      }, {
        key: "on",
        value: function on(event, handler) {
          if (!this.listeners[event]) {
            this.listeners[event] = [];
          }
          this.listeners[event].push(handler);
        }
      }, {
        key: "off",
        value: function off(event, handler) {
          var listeners = this.listeners[event];
          if (!listeners) {
            return;
          }
          this.listeners[event] = listeners.filter(function(l) {
            return l !== handler;
          });
        }
      }, {
        key: "firstLine",
        value: function firstLine() {
          return 0;
        }
      }, {
        key: "lastLine",
        value: function lastLine() {
          return this.lineCount() - 1;
        }
      }, {
        key: "lineCount",
        value: function lineCount() {
          return this.editor.getModel().getLineCount();
        }
      }, {
        key: "defaultTextHeight",
        value: function defaultTextHeight() {
          return 1;
        }
      }, {
        key: "getLine",
        value: function getLine(line) {
          if (line < 0) {
            return "";
          }
          var model = this.editor.getModel();
          var maxLines = model.getLineCount();
          if (line + 1 > maxLines) {
            line = maxLines - 1;
          }
          return this.editor.getModel().getLineContent(line + 1);
        }
      }, {
        key: "getAnchorForSelection",
        value: function getAnchorForSelection(selection) {
          if (selection.isEmpty()) {
            return selection.getPosition();
          }
          var selDir = selection.getDirection();
          return selDir === _editor.SelectionDirection.LTR ? selection.getStartPosition() : selection.getEndPosition();
        }
      }, {
        key: "getHeadForSelection",
        value: function getHeadForSelection(selection) {
          if (selection.isEmpty()) {
            return selection.getPosition();
          }
          var selDir = selection.getDirection();
          return selDir === _editor.SelectionDirection.LTR ? selection.getEndPosition() : selection.getStartPosition();
        }
      }, {
        key: "getCursor",
        value: function getCursor() {
          var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          if (!type) {
            return toCmPos(this.editor.getPosition());
          }
          var sel = this.editor.getSelection();
          var pos;
          if (sel.isEmpty()) {
            pos = sel.getPosition();
          } else if (type === "anchor") {
            pos = this.getAnchorForSelection(sel);
          } else {
            pos = this.getHeadForSelection(sel);
          }
          return toCmPos(pos);
        }
      }, {
        key: "getRange",
        value: function getRange(start, end) {
          var p1 = toMonacoPos(start);
          var p2 = toMonacoPos(end);
          return this.editor.getModel().getValueInRange(_editor.Range.fromPositions(p1, p2));
        }
      }, {
        key: "getSelection",
        value: function getSelection() {
          var list = [];
          var editor = this.editor;
          editor.getSelections().map(function(sel) {
            list.push(editor.getModel().getValueInRange(sel));
          });
          return list.join("\n");
        }
      }, {
        key: "replaceRange",
        value: function replaceRange(text, start, end) {
          var p1 = toMonacoPos(start);
          var p2 = !end ? p1 : toMonacoPos(end);
          this.editor.executeEdits("vim", [{
            text,
            range: _editor.Range.fromPositions(p1, p2)
          }]);
          this.pushUndoStop();
        }
      }, {
        key: "pushUndoStop",
        value: function pushUndoStop() {
          this.editor.pushUndoStop();
        }
      }, {
        key: "setCursor",
        value: function setCursor(line, ch) {
          var pos = line;
          if (_typeof(line) !== "object") {
            pos = {};
            pos.line = line;
            pos.ch = ch;
          }
          var monacoPos = this.editor.getModel().validatePosition(toMonacoPos(pos));
          this.editor.setPosition(toMonacoPos(pos));
          this.editor.revealPosition(monacoPos);
        }
      }, {
        key: "somethingSelected",
        value: function somethingSelected() {
          return !this.editor.getSelection().isEmpty();
        }
      }, {
        key: "operation",
        value: function operation(fn, force) {
          return fn();
        }
      }, {
        key: "listSelections",
        value: function listSelections() {
          var _this = this;
          var selections = this.editor.getSelections();
          if (!selections.length || this.inVirtualSelectionMode) {
            return [{
              anchor: this.getCursor("anchor"),
              head: this.getCursor("head")
            }];
          }
          return selections.map(function(sel) {
            var pos = sel.getPosition();
            var start = sel.getStartPosition();
            var end = sel.getEndPosition();
            return {
              anchor: _this.clipPos(toCmPos(_this.getAnchorForSelection(sel))),
              head: _this.clipPos(toCmPos(_this.getHeadForSelection(sel)))
            };
          });
        }
      }, {
        key: "focus",
        value: function focus() {
          this.editor.focus();
        }
      }, {
        key: "setSelections",
        value: function setSelections(selections, primIndex) {
          var hasSel = !!this.editor.getSelections().length;
          var sels = selections.map(function(sel2, index) {
            var anchor = sel2.anchor, head = sel2.head;
            if (hasSel) {
              return _editor.Selection.fromPositions(toMonacoPos(anchor), toMonacoPos(head));
            } else {
              return _editor.Selection.fromPositions(toMonacoPos(head), toMonacoPos(anchor));
            }
          });
          if (!primIndex) {
          } else if (sels[primIndex]) {
            sels.push(sels.splice(primIndex, 1)[0]);
          }
          if (!sels.length) {
            return;
          }
          var sel = sels[0];
          var posToReveal;
          if (sel.getDirection() === _editor.SelectionDirection.LTR) {
            posToReveal = sel.getEndPosition();
          } else {
            posToReveal = sel.getStartPosition();
          }
          this.editor.setSelections(sels);
          this.editor.revealPosition(posToReveal);
        }
      }, {
        key: "setSelection",
        value: function setSelection(frm, to) {
          var range = _editor.Range.fromPositions(toMonacoPos(frm), toMonacoPos(to));
          this.editor.setSelection(range);
        }
      }, {
        key: "getSelections",
        value: function getSelections() {
          var editor = this.editor;
          return editor.getSelections().map(function(sel) {
            return editor.getModel().getValueInRange(sel);
          });
        }
      }, {
        key: "replaceSelections",
        value: function replaceSelections(texts) {
          var editor = this.editor;
          editor.getSelections().forEach(function(sel, index) {
            editor.executeEdits("vim", [{
              range: sel,
              text: texts[index],
              forceMoveMarkers: false
            }]);
          });
        }
      }, {
        key: "toggleOverwrite",
        value: function toggleOverwrite(toggle) {
          if (toggle) {
            this.enterVimMode();
            this.replaceMode = true;
          } else {
            this.leaveVimMode();
            this.replaceMode = false;
            this.replaceStack = [];
          }
        }
      }, {
        key: "charCoords",
        value: function charCoords(pos, mode) {
          return {
            top: pos.line,
            left: pos.ch
          };
        }
      }, {
        key: "coordsChar",
        value: function coordsChar(pos, mode) {
          if (mode === "local") {
          }
        }
      }, {
        key: "clipPos",
        value: function clipPos(p) {
          var pos = this.editor.getModel().validatePosition(toMonacoPos(p));
          return toCmPos(pos);
        }
      }, {
        key: "setBookmark",
        value: function setBookmark(cursor, options) {
          var bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);
          if (!options || !options.insertLeft) {
            bm.$insertRight = true;
          }
          this.marks[bm.id] = bm;
          return bm;
        }
      }, {
        key: "getScrollInfo",
        value: function getScrollInfo() {
          var editor = this.editor;
          var _editor$getVisibleRan = editor.getVisibleRanges(), _editor$getVisibleRan2 = _slicedToArray(_editor$getVisibleRan, 1), range = _editor$getVisibleRan2[0];
          return {
            left: 0,
            top: range.startLineNumber - 1,
            height: editor.getModel().getLineCount(),
            clientHeight: range.endLineNumber - range.startLineNumber + 1
          };
        }
      }, {
        key: "triggerEditorAction",
        value: function triggerEditorAction(action) {
          this.editor.trigger("vim", action);
        }
      }, {
        key: "dispose",
        value: function dispose() {
          this.dispatch("dispose");
          this.removeOverlay();
          if (CMAdapter2.keyMap.vim) {
            CMAdapter2.keyMap.vim.detach(this);
          }
          this.disposables.forEach(function(d) {
            return d.dispose();
          });
        }
      }, {
        key: "getInputField",
        value: function getInputField() {
        }
      }, {
        key: "getWrapperElement",
        value: function getWrapperElement() {
        }
      }, {
        key: "enterVimMode",
        value: function enterVimMode() {
          var toVim = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          this.ctxInsert.set(false);
          var config = this.getConfiguration();
          this.initialCursorWidth = config.viewInfo.cursorWidth || 0;
          this.editor.updateOptions({
            cursorWidth: config.fontInfo.typicalFullwidthCharacterWidth,
            cursorBlinking: "solid",
            cursorStyle: "block"
          });
        }
      }, {
        key: "leaveVimMode",
        value: function leaveVimMode() {
          this.ctxInsert.set(true);
          this.editor.updateOptions({
            cursorWidth: this.initialCursorWidth || 0,
            cursorBlinking: "blink",
            cursorStyle: "line"
          });
        }
      }, {
        key: "virtualSelectionMode",
        value: function virtualSelectionMode() {
          return this.inVirtualSelectionMode;
        }
      }, {
        key: "markText",
        value: function markText() {
          return {
            clear: function clear() {
            },
            find: function find() {
            }
          };
        }
      }, {
        key: "getUserVisibleLines",
        value: function getUserVisibleLines() {
          var ranges = this.editor.getVisibleRanges();
          if (!ranges.length) {
            return {
              top: 0,
              bottom: 0
            };
          }
          var res = {
            top: Infinity,
            bottom: 0
          };
          ranges.reduce(function(acc, range) {
            if (range.startLineNumber < acc.top) {
              acc.top = range.startLineNumber;
            }
            if (range.endLineNumber > acc.bottom) {
              acc.bottom = range.endLineNumber;
            }
            return acc;
          }, res);
          res.top -= 1;
          res.bottom -= 1;
          return res;
        }
      }, {
        key: "findPosV",
        value: function findPosV(startPos, amount, unit) {
          var editor = this.editor;
          var finalAmount = amount;
          var finalUnit = unit;
          var pos = toMonacoPos(startPos);
          if (unit === "page") {
            var editorHeight = editor.getLayoutInfo().height;
            var lineHeight = this.getConfiguration().fontInfo.lineHeight;
            finalAmount = finalAmount * Math.floor(editorHeight / lineHeight);
            finalUnit = "line";
          }
          if (finalUnit === "line") {
            pos.lineNumber += finalAmount;
          }
          return toCmPos(pos);
        }
      }, {
        key: "findMatchingBracket",
        value: function findMatchingBracket(pos) {
          var mPos = toMonacoPos(pos);
          var model = this.editor.getModel();
          var res;
          if (model.bracketPairs) {
            res = model.bracketPairs.matchBracket(mPos);
          } else {
            var _model$matchBracket;
            res = (_model$matchBracket = model.matchBracket) === null || _model$matchBracket === void 0 ? void 0 : _model$matchBracket.call(model, mPos);
          }
          if (!res || !(res.length === 2)) {
            return {
              to: null
            };
          }
          return {
            to: toCmPos(res[1].getStartPosition())
          };
        }
      }, {
        key: "findFirstNonWhiteSpaceCharacter",
        value: function findFirstNonWhiteSpaceCharacter(line) {
          return this.editor.getModel().getLineFirstNonWhitespaceColumn(line + 1) - 1;
        }
      }, {
        key: "scrollTo",
        value: function scrollTo(x, y) {
          if (!x && !y) {
            return;
          }
          if (!x) {
            if (y < 0) {
              y = this.editor.getPosition().lineNumber - y;
            }
            this.editor.setScrollTop(this.editor.getTopForLineNumber(y + 1));
          }
        }
      }, {
        key: "moveCurrentLineTo",
        value: function moveCurrentLineTo(viewPosition) {
          var _editor$_revealRange;
          var editor = this.editor;
          var pos = editor.getPosition();
          var range = _editor.Range.fromPositions(pos, pos);
          switch (viewPosition) {
            case "top":
              editor.revealRangeAtTop(range);
              return;
            case "center":
              editor.revealRangeInCenter(range);
              return;
            case "bottom":
              (_editor$_revealRange = editor._revealRange) === null || _editor$_revealRange === void 0 || _editor$_revealRange.call(editor, range, VerticalRevealType.Bottom);
              return;
          }
        }
      }, {
        key: "getSearchCursor",
        value: function getSearchCursor(query, pos) {
          var matchCase = false;
          var isRegex = false;
          if (query instanceof RegExp && !query.global) {
            matchCase = !query.ignoreCase;
            query = query.source;
            isRegex = true;
          }
          if (pos.ch == void 0) pos.ch = Number.MAX_VALUE;
          var monacoPos = toMonacoPos(pos);
          var context = this;
          var editor = this.editor;
          var lastSearch = null;
          var model = editor.getModel();
          var matches = model.findMatches(query, false, isRegex, matchCase) || [];
          return {
            getMatches: function getMatches() {
              return matches;
            },
            findNext: function findNext() {
              return this.find(false);
            },
            findPrevious: function findPrevious() {
              return this.find(true);
            },
            jumpTo: function jumpTo(index) {
              if (!matches || !matches.length) {
                return false;
              }
              var match = matches[index];
              lastSearch = match.range;
              context.highlightRanges([lastSearch], "currentFindMatch");
              context.highlightRanges(matches.map(function(m) {
                return m.range;
              }).filter(function(r) {
                return !r.equalsRange(lastSearch);
              }));
              return lastSearch;
            },
            find: function find(back) {
              if (!matches || !matches.length) {
                return false;
              }
              var match;
              if (back) {
                var _pos = lastSearch ? lastSearch.getStartPosition() : monacoPos;
                match = model.findPreviousMatch(query, _pos, isRegex, matchCase);
                if (!match || !match.range.getStartPosition().isBeforeOrEqual(_pos)) {
                  return false;
                }
              } else {
                var _pos2 = lastSearch ? model.getPositionAt(model.getOffsetAt(lastSearch.getEndPosition()) + 1) : monacoPos;
                match = model.findNextMatch(query, _pos2, isRegex, matchCase);
                if (!match || !_pos2.isBeforeOrEqual(match.range.getStartPosition())) {
                  return false;
                }
              }
              lastSearch = match.range;
              context.highlightRanges([lastSearch], "currentFindMatch");
              context.highlightRanges(matches.map(function(m) {
                return m.range;
              }).filter(function(r) {
                return !r.equalsRange(lastSearch);
              }));
              return lastSearch;
            },
            from: function from() {
              return lastSearch && toCmPos(lastSearch.getStartPosition());
            },
            to: function to() {
              return lastSearch && toCmPos(lastSearch.getEndPosition());
            },
            replace: function replace(text) {
              if (lastSearch) {
                editor.executeEdits("vim", [{
                  range: lastSearch,
                  text,
                  forceMoveMarkers: true
                }], function(edits) {
                  var _edits$0$range = edits[0].range, endLineNumber = _edits$0$range.endLineNumber, endColumn = _edits$0$range.endColumn;
                  lastSearch = lastSearch.setEndPosition(endLineNumber, endColumn);
                });
                editor.setPosition(lastSearch.getStartPosition());
              }
            }
          };
        }
      }, {
        key: "highlightRanges",
        value: function highlightRanges(ranges) {
          var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "findMatch";
          var decorationKey = "decoration".concat(className);
          this[decorationKey] = this.editor.deltaDecorations(this[decorationKey] || [], ranges.map(function(range) {
            return {
              range,
              options: {
                stickiness: _editor.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                zIndex: 13,
                className,
                showIfCollapsed: true
              }
            };
          }));
          return this[decorationKey];
        }
      }, {
        key: "addOverlay",
        value: function addOverlay(_ref, hasBoundary, style) {
          var query = _ref.query;
          var matchCase = false;
          var isRegex = false;
          if (query && query instanceof RegExp && !query.global) {
            isRegex = true;
            matchCase = !query.ignoreCase;
            query = query.source;
          }
          var match = this.editor.getModel().findNextMatch(query, this.editor.getPosition(), isRegex, matchCase);
          if (!match || !match.range) {
            return;
          }
          this.highlightRanges([match.range]);
        }
      }, {
        key: "removeOverlay",
        value: function removeOverlay() {
          var _this2 = this;
          ["currentFindMatch", "findMatch"].forEach(function(key) {
            _this2.editor.deltaDecorations(_this2["decoration".concat(key)] || [], []);
          });
        }
      }, {
        key: "scrollIntoView",
        value: function scrollIntoView(pos) {
          if (!pos) {
            return;
          }
          this.editor.revealPosition(toMonacoPos(pos));
        }
      }, {
        key: "moveH",
        value: function moveH(units, type) {
          if (type !== "char") {
            return;
          }
          var pos = this.editor.getPosition();
          this.editor.setPosition(new _editor.Position(pos.lineNumber, pos.column + units));
        }
      }, {
        key: "scanForBracket",
        value: function scanForBracket(pos, dir, dd, config) {
          var bracketRegex = config.bracketRegex;
          var mPos = toMonacoPos(pos);
          var model = this.editor.getModel();
          var searchFunc = (dir === -1 ? model.findPreviousMatch : model.findNextMatch).bind(model);
          var stack = [];
          var iterations = 0;
          while (true) {
            if (iterations > 10) {
              return void 0;
            }
            var match = searchFunc(bracketRegex.source, mPos, true, true, null, true);
            var thisBracket = match.matches[0];
            if (match === void 0) {
              return void 0;
            }
            var matchingBracket = CMAdapter2.matchingBrackets[thisBracket];
            if (matchingBracket && matchingBracket.charAt(1) === ">" == dir > 0) {
              stack.push(thisBracket);
            } else if (stack.length === 0) {
              var res = match.range.getStartPosition();
              return {
                pos: toCmPos(res)
              };
            } else {
              stack.pop();
            }
            mPos = model.getPositionAt(model.getOffsetAt(match.range.getStartPosition()) + dir);
            iterations += 1;
          }
        }
      }, {
        key: "indexFromPos",
        value: function indexFromPos(pos) {
          return this.editor.getModel().getOffsetAt(toMonacoPos(pos));
        }
      }, {
        key: "posFromIndex",
        value: function posFromIndex(offset) {
          return toCmPos(this.editor.getModel().getPositionAt(offset));
        }
      }, {
        key: "indentLine",
        value: function indentLine(line) {
          var indentRight = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var editor = this.editor;
          var cursorConfig;
          if (editor._getViewModel) {
            cursorConfig = editor._getViewModel().cursorConfig;
          } else {
            cursorConfig = editor._getCursors().context.config;
          }
          var pos = new _editor.Position(line + 1, 1);
          var sel = _editor.Selection.fromPositions(pos, pos);
          editor.executeCommand("vim", new _shiftCommand.ShiftCommand(sel, {
            isUnshift: !indentRight,
            tabSize: cursorConfig.tabSize,
            indentSize: cursorConfig.indentSize,
            insertSpaces: cursorConfig.insertSpaces,
            useTabStops: cursorConfig.useTabStops,
            autoIndent: cursorConfig.autoIndent
          }));
        }
      }, {
        key: "setStatusBar",
        value: function setStatusBar(statusBar) {
          this.statusBar = statusBar;
        }
      }, {
        key: "openDialog",
        value: function openDialog(html, callback, options) {
          if (!this.statusBar) {
            return;
          }
          return this.statusBar.setSec(html, callback, options);
        }
      }, {
        key: "openNotification",
        value: function openNotification(html) {
          if (!this.statusBar) {
            return;
          }
          this.statusBar.showNotification(html);
        }
      }, {
        key: "smartIndent",
        value: function smartIndent() {
          this.editor.getAction("editor.action.formatSelection").run();
        }
      }, {
        key: "moveCursorTo",
        value: function moveCursorTo(to) {
          var newPos = this.editor.getPosition();
          if (to === "start") {
            newPos.column = 1;
          } else if (to === "end") {
            newPos.column = this.editor.getModel().getLineMaxColumn(newPos.lineNumber);
          }
          this.editor.setPosition(newPos);
        }
      }, {
        key: "execCommand",
        value: function execCommand(command) {
          switch (command) {
            case "goLineLeft":
              this.moveCursorTo("start");
              break;
            case "goLineRight":
              this.moveCursorTo("end");
              break;
            case "indentAuto":
              this.smartIndent();
              break;
          }
        }
      }]);
    }();
    CMAdapter.Pos = Pos;
    CMAdapter.signal = signal;
    CMAdapter.on = dummy("on");
    CMAdapter.off = dummy("off");
    CMAdapter.addClass = dummy("addClass");
    CMAdapter.rmClass = dummy("rmClass");
    CMAdapter.defineOption = dummy("defineOption");
    CMAdapter.keyMap = {
      "default": function _default(key) {
        return function(cm) {
          return true;
        };
      }
    };
    CMAdapter.matchingBrackets = {
      "(": ")>",
      ")": "(<",
      "[": "]>",
      "]": "[<",
      "{": "}>",
      "}": "{<",
      "<": ">>",
      ">": "<<"
    };
    CMAdapter.isWordChar = isWordCharBasic;
    CMAdapter.keyName = monacoToCmKey;
    CMAdapter.StringStream = StringStream;
    CMAdapter.e_stop = function(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
      CMAdapter.e_preventDefault(e);
      return false;
    };
    CMAdapter.e_preventDefault = function(e) {
      if (e.preventDefault) {
        e.preventDefault();
        if (e.browserEvent) {
          e.browserEvent.preventDefault();
        }
      } else {
        e.returnValue = false;
      }
      return false;
    };
    CMAdapter.commands = {
      redo: function redo(cm) {
        cm.editor.getModel().redo();
      },
      undo: function undo(cm) {
        cm.editor.getModel().undo();
      },
      newlineAndIndent: function newlineAndIndent(cm) {
        cm.triggerEditorAction("editor.action.insertLineAfter");
      }
    };
    CMAdapter.lookupKey = function lookupKey(key, map, handle) {
      if (typeof map === "string") {
        map = CMAdapter.keyMap[map];
      }
      var found = typeof map == "function" ? map(key) : map[key];
      if (found === false) return "nothing";
      if (found === "...") return "multi";
      if (found != null && handle(found)) return "handled";
      if (map.fallthrough) {
        if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);
        for (var i = 0; i < map.fallthrough.length; i++) {
          var result = lookupKey(key, map.fallthrough[i], handle);
          if (result) return result;
        }
      }
    };
    CMAdapter.defineExtension = function(name, fn) {
      CMAdapter.prototype[name] = fn;
    };
    var _initialiseProps = function _initialiseProps2() {
      var _this3 = this;
      this.handleKeyDown = function(e) {
        if (e.browserEvent.defaultPrevented & e.keyCode !== _editor.KeyCode.Escape) {
          return;
        }
        if (!_this3.attached) {
          return;
        }
        var key = monacoToCmKey(e);
        if (_this3.replaceMode) {
          _this3.handleReplaceMode(key, e);
        }
        if (!key) {
          return;
        }
        var keymap = _this3.state.keyMap;
        if (CMAdapter.keyMap[keymap] && CMAdapter.keyMap[keymap].call) {
          var cmd = CMAdapter.keyMap[keymap].call(key, _this3);
          if (cmd) {
            e.preventDefault();
            e.stopPropagation();
            try {
              cmd();
            } catch (err) {
              console.error(err);
            }
          }
        }
      };
      this.handleCursorChange = function(e) {
        var position = e.position, source = e.source;
        var editor = _this3.editor;
        var selection = editor.getSelection();
        if (!_this3.ctxInsert.get() && e.source === "mouse" && selection.isEmpty()) {
          var maxCol = editor.getModel().getLineMaxColumn(position.lineNumber);
          if (e.position.column === maxCol) {
            editor.setPosition(new _editor.Position(e.position.lineNumber, maxCol - 1));
            return;
          }
        }
        _this3.dispatch("cursorActivity", _this3, e);
      };
      this.handleChange = function(e) {
        var changes = e.changes;
        var change = {
          text: changes.reduce(function(acc, change2) {
            acc.push(change2.text);
            return acc;
          }, []),
          origin: "+input"
        };
        var curOp = _this3.curOp = _this3.curOp || {};
        if (!curOp.changeHandlers) {
          curOp.changeHandlers = _this3.listeners["change"] && _this3.listeners["change"].slice();
        }
        if (_this3.virtualSelectionMode()) {
          return;
        }
        if (!curOp.lastChange) {
          curOp.lastChange = curOp.change = change;
        } else {
          curOp.lastChange.next = curOp.lastChange = change;
        }
        _this3.dispatch("change", _this3, change);
      };
    };
    var _default2 = exports["default"] = CMAdapter;
  }
});

// node_modules/monaco-vim/lib/cm/keymap_vim.js
var require_keymap_vim = __commonJS({
  "node_modules/monaco-vim/lib/cm/keymap_vim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.Vim = void 0;
    var _cm_adapter = _interopRequireDefault(require_cm_adapter());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    var Pos = _cm_adapter["default"].Pos;
    function transformCursor(cm, range) {
      var vim = cm.state.vim;
      if (!vim || vim.insertMode) return range.head;
      var head = vim.sel.head;
      if (!head) return range.head;
      if (vim.visualBlock) {
        if (range.head.line != head.line) {
          return;
        }
      }
      if (range.from() == range.anchor && !range.empty()) {
        if (range.head.line == head.line && range.head.ch != head.ch) return new Pos(range.head.line, range.head.ch - 1);
      }
      return range.head;
    }
    var defaultKeymap = [
      // Key to key mapping. This goes first to make it possible to override
      // existing mappings.
      {
        keys: "<Left>",
        type: "keyToKey",
        toKeys: "h"
      },
      {
        keys: "<Right>",
        type: "keyToKey",
        toKeys: "l"
      },
      {
        keys: "<Up>",
        type: "keyToKey",
        toKeys: "k"
      },
      {
        keys: "<Down>",
        type: "keyToKey",
        toKeys: "j"
      },
      {
        keys: "g<Up>",
        type: "keyToKey",
        toKeys: "gk"
      },
      {
        keys: "g<Down>",
        type: "keyToKey",
        toKeys: "gj"
      },
      {
        keys: "<Space>",
        type: "keyToKey",
        toKeys: "l"
      },
      {
        keys: "<BS>",
        type: "keyToKey",
        toKeys: "h",
        context: "normal"
      },
      {
        keys: "<Del>",
        type: "keyToKey",
        toKeys: "x",
        context: "normal"
      },
      {
        keys: "<C-Space>",
        type: "keyToKey",
        toKeys: "W"
      },
      {
        keys: "<C-BS>",
        type: "keyToKey",
        toKeys: "B",
        context: "normal"
      },
      {
        keys: "<S-Space>",
        type: "keyToKey",
        toKeys: "w"
      },
      {
        keys: "<S-BS>",
        type: "keyToKey",
        toKeys: "b",
        context: "normal"
      },
      {
        keys: "<C-n>",
        type: "keyToKey",
        toKeys: "j"
      },
      {
        keys: "<C-p>",
        type: "keyToKey",
        toKeys: "k"
      },
      {
        keys: "<C-[>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-c>",
        type: "keyToKey",
        toKeys: "<Esc>"
      },
      {
        keys: "<C-[>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "<C-c>",
        type: "keyToKey",
        toKeys: "<Esc>",
        context: "insert"
      },
      {
        keys: "s",
        type: "keyToKey",
        toKeys: "cl",
        context: "normal"
      },
      {
        keys: "s",
        type: "keyToKey",
        toKeys: "c",
        context: "visual"
      },
      {
        keys: "S",
        type: "keyToKey",
        toKeys: "cc",
        context: "normal"
      },
      {
        keys: "S",
        type: "keyToKey",
        toKeys: "VdO",
        context: "visual"
      },
      {
        keys: "<Home>",
        type: "keyToKey",
        toKeys: "0"
      },
      {
        keys: "<End>",
        type: "keyToKey",
        toKeys: "$"
      },
      {
        keys: "<PageUp>",
        type: "keyToKey",
        toKeys: "<C-b>"
      },
      {
        keys: "<PageDown>",
        type: "keyToKey",
        toKeys: "<C-f>"
      },
      {
        keys: "<CR>",
        type: "keyToKey",
        toKeys: "j^",
        context: "normal"
      },
      {
        keys: "<Ins>",
        type: "keyToKey",
        toKeys: "i",
        context: "normal"
      },
      {
        keys: "<Ins>",
        type: "action",
        action: "toggleOverwrite",
        context: "insert"
      },
      // Motions
      {
        keys: "H",
        type: "motion",
        motion: "moveToTopLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "M",
        type: "motion",
        motion: "moveToMiddleLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "L",
        type: "motion",
        motion: "moveToBottomLine",
        motionArgs: {
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "h",
        type: "motion",
        motion: "moveByCharacters",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "l",
        type: "motion",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "j",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "k",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "gj",
        type: "motion",
        motion: "moveByDisplayLines",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "gk",
        type: "motion",
        motion: "moveByDisplayLines",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "w",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: false
        }
      },
      {
        keys: "W",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: false,
          bigWord: true
        }
      },
      {
        keys: "e",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: true,
          inclusive: true
        }
      },
      {
        keys: "E",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: true,
          wordEnd: true,
          bigWord: true,
          inclusive: true
        }
      },
      {
        keys: "b",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false
        }
      },
      {
        keys: "B",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false,
          bigWord: true
        }
      },
      {
        keys: "ge",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: true,
          inclusive: true
        }
      },
      {
        keys: "gE",
        type: "motion",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: true,
          bigWord: true,
          inclusive: true
        }
      },
      {
        keys: "{",
        type: "motion",
        motion: "moveByParagraph",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "}",
        type: "motion",
        motion: "moveByParagraph",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "(",
        type: "motion",
        motion: "moveBySentence",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: ")",
        type: "motion",
        motion: "moveBySentence",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-f>",
        type: "motion",
        motion: "moveByPage",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-b>",
        type: "motion",
        motion: "moveByPage",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "<C-d>",
        type: "motion",
        motion: "moveByScroll",
        motionArgs: {
          forward: true,
          explicitRepeat: true
        }
      },
      {
        keys: "<C-u>",
        type: "motion",
        motion: "moveByScroll",
        motionArgs: {
          forward: false,
          explicitRepeat: true
        }
      },
      {
        keys: "gg",
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: {
          forward: false,
          explicitRepeat: true,
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "G",
        type: "motion",
        motion: "moveToLineOrEdgeOfDocument",
        motionArgs: {
          forward: true,
          explicitRepeat: true,
          linewise: true,
          toJumplist: true
        }
      },
      {
        keys: "g$",
        type: "motion",
        motion: "moveToEndOfDisplayLine"
      },
      {
        keys: "g^",
        type: "motion",
        motion: "moveToStartOfDisplayLine"
      },
      {
        keys: "g0",
        type: "motion",
        motion: "moveToStartOfDisplayLine"
      },
      {
        keys: "0",
        type: "motion",
        motion: "moveToStartOfLine"
      },
      {
        keys: "^",
        type: "motion",
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "+",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          toFirstChar: true
        }
      },
      {
        keys: "-",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: false,
          toFirstChar: true
        }
      },
      {
        keys: "_",
        type: "motion",
        motion: "moveByLines",
        motionArgs: {
          forward: true,
          toFirstChar: true,
          repeatOffset: -1
        }
      },
      {
        keys: "$",
        type: "motion",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        }
      },
      {
        keys: "%",
        type: "motion",
        motion: "moveToMatchedSymbol",
        motionArgs: {
          inclusive: true,
          toJumplist: true
        }
      },
      {
        keys: "f<character>",
        type: "motion",
        motion: "moveToCharacter",
        motionArgs: {
          forward: true,
          inclusive: true
        }
      },
      {
        keys: "F<character>",
        type: "motion",
        motion: "moveToCharacter",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "t<character>",
        type: "motion",
        motion: "moveTillCharacter",
        motionArgs: {
          forward: true,
          inclusive: true
        }
      },
      {
        keys: "T<character>",
        type: "motion",
        motion: "moveTillCharacter",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: ";",
        type: "motion",
        motion: "repeatLastCharacterSearch",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: ",",
        type: "motion",
        motion: "repeatLastCharacterSearch",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "'<character>",
        type: "motion",
        motion: "goToMark",
        motionArgs: {
          toJumplist: true,
          linewise: true
        }
      },
      {
        keys: "`<character>",
        type: "motion",
        motion: "goToMark",
        motionArgs: {
          toJumplist: true
        }
      },
      {
        keys: "]`",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "[`",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: false
        }
      },
      {
        keys: "]'",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "['",
        type: "motion",
        motion: "jumpToMark",
        motionArgs: {
          forward: false,
          linewise: true
        }
      },
      // the next two aren't motions but must come before more general motion declarations
      {
        keys: "]p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: true,
          isEdit: true,
          matchIndent: true
        }
      },
      {
        keys: "[p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: false,
          isEdit: true,
          matchIndent: true
        }
      },
      {
        keys: "]<character>",
        type: "motion",
        motion: "moveToSymbol",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "[<character>",
        type: "motion",
        motion: "moveToSymbol",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "|",
        type: "motion",
        motion: "moveToColumn"
      },
      {
        keys: "o",
        type: "motion",
        motion: "moveToOtherHighlightedEnd",
        context: "visual"
      },
      {
        keys: "O",
        type: "motion",
        motion: "moveToOtherHighlightedEnd",
        motionArgs: {
          sameLine: true
        },
        context: "visual"
      },
      // Operators
      {
        keys: "d",
        type: "operator",
        operator: "delete"
      },
      {
        keys: "y",
        type: "operator",
        operator: "yank"
      },
      {
        keys: "c",
        type: "operator",
        operator: "change"
      },
      {
        keys: "=",
        type: "operator",
        operator: "indentAuto"
      },
      {
        keys: ">",
        type: "operator",
        operator: "indent",
        operatorArgs: {
          indentRight: true
        }
      },
      {
        keys: "<",
        type: "operator",
        operator: "indent",
        operatorArgs: {
          indentRight: false
        }
      },
      {
        keys: "g~",
        type: "operator",
        operator: "changeCase"
      },
      {
        keys: "gu",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: true
        },
        isEdit: true
      },
      {
        keys: "gU",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: false
        },
        isEdit: true
      },
      {
        keys: "n",
        type: "motion",
        motion: "findNext",
        motionArgs: {
          forward: true,
          toJumplist: true
        }
      },
      {
        keys: "N",
        type: "motion",
        motion: "findNext",
        motionArgs: {
          forward: false,
          toJumplist: true
        }
      },
      {
        keys: "gn",
        type: "motion",
        motion: "findAndSelectNextInclusive",
        motionArgs: {
          forward: true
        }
      },
      {
        keys: "gN",
        type: "motion",
        motion: "findAndSelectNextInclusive",
        motionArgs: {
          forward: false
        }
      },
      // Operator-Motion dual commands
      {
        keys: "x",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        },
        operatorMotionArgs: {
          visualLine: false
        }
      },
      {
        keys: "X",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByCharacters",
        motionArgs: {
          forward: false
        },
        operatorMotionArgs: {
          visualLine: true
        }
      },
      {
        keys: "D",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        },
        context: "normal"
      },
      {
        keys: "D",
        type: "operator",
        operator: "delete",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "Y",
        type: "operatorMotion",
        operator: "yank",
        motion: "expandToLine",
        motionArgs: {
          linewise: true
        },
        context: "normal"
      },
      {
        keys: "Y",
        type: "operator",
        operator: "yank",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "C",
        type: "operatorMotion",
        operator: "change",
        motion: "moveToEol",
        motionArgs: {
          inclusive: true
        },
        context: "normal"
      },
      {
        keys: "C",
        type: "operator",
        operator: "change",
        operatorArgs: {
          linewise: true
        },
        context: "visual"
      },
      {
        keys: "~",
        type: "operatorMotion",
        operator: "changeCase",
        motion: "moveByCharacters",
        motionArgs: {
          forward: true
        },
        operatorArgs: {
          shouldMoveCursor: true
        },
        context: "normal"
      },
      {
        keys: "~",
        type: "operator",
        operator: "changeCase",
        context: "visual"
      },
      {
        keys: "<C-u>",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveToStartOfLine",
        context: "insert"
      },
      {
        keys: "<C-w>",
        type: "operatorMotion",
        operator: "delete",
        motion: "moveByWords",
        motionArgs: {
          forward: false,
          wordEnd: false
        },
        context: "insert"
      },
      //ignore C-w in normal mode
      {
        keys: "<C-w>",
        type: "idle",
        context: "normal"
      },
      // Actions
      {
        keys: "<C-i>",
        type: "action",
        action: "jumpListWalk",
        actionArgs: {
          forward: true
        }
      },
      {
        keys: "<C-o>",
        type: "action",
        action: "jumpListWalk",
        actionArgs: {
          forward: false
        }
      },
      {
        keys: "<C-e>",
        type: "action",
        action: "scroll",
        actionArgs: {
          forward: true,
          linewise: true
        }
      },
      {
        keys: "<C-y>",
        type: "action",
        action: "scroll",
        actionArgs: {
          forward: false,
          linewise: true
        }
      },
      {
        keys: "a",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "charAfter"
        },
        context: "normal"
      },
      {
        keys: "A",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "eol"
        },
        context: "normal"
      },
      {
        keys: "A",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "endOfSelectedArea"
        },
        context: "visual"
      },
      {
        keys: "i",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "inplace"
        },
        context: "normal"
      },
      {
        keys: "gi",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "lastEdit"
        },
        context: "normal"
      },
      {
        keys: "I",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "firstNonBlank"
        },
        context: "normal"
      },
      {
        keys: "gI",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "bol"
        },
        context: "normal"
      },
      {
        keys: "I",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          insertAt: "startOfSelectedArea"
        },
        context: "visual"
      },
      {
        keys: "o",
        type: "action",
        action: "newLineAndEnterInsertMode",
        isEdit: true,
        interlaceInsertRepeat: true,
        actionArgs: {
          after: true
        },
        context: "normal"
      },
      {
        keys: "O",
        type: "action",
        action: "newLineAndEnterInsertMode",
        isEdit: true,
        interlaceInsertRepeat: true,
        actionArgs: {
          after: false
        },
        context: "normal"
      },
      {
        keys: "v",
        type: "action",
        action: "toggleVisualMode"
      },
      {
        keys: "V",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          linewise: true
        }
      },
      {
        keys: "<C-v>",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          blockwise: true
        }
      },
      {
        keys: "<C-q>",
        type: "action",
        action: "toggleVisualMode",
        actionArgs: {
          blockwise: true
        }
      },
      {
        keys: "gv",
        type: "action",
        action: "reselectLastSelection"
      },
      {
        keys: "J",
        type: "action",
        action: "joinLines",
        isEdit: true
      },
      {
        keys: "gJ",
        type: "action",
        action: "joinLines",
        actionArgs: {
          keepSpaces: true
        },
        isEdit: true
      },
      {
        keys: "p",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: true,
          isEdit: true
        }
      },
      {
        keys: "P",
        type: "action",
        action: "paste",
        isEdit: true,
        actionArgs: {
          after: false,
          isEdit: true
        }
      },
      {
        keys: "r<character>",
        type: "action",
        action: "replace",
        isEdit: true
      },
      {
        keys: "@<character>",
        type: "action",
        action: "replayMacro"
      },
      {
        keys: "q<character>",
        type: "action",
        action: "enterMacroRecordMode"
      },
      // Handle Replace-mode as a special case of insert mode.
      {
        keys: "R",
        type: "action",
        action: "enterInsertMode",
        isEdit: true,
        actionArgs: {
          replace: true
        },
        context: "normal"
      },
      {
        keys: "R",
        type: "operator",
        operator: "change",
        operatorArgs: {
          linewise: true,
          fullLine: true
        },
        context: "visual",
        exitVisualBlock: true
      },
      {
        keys: "u",
        type: "action",
        action: "undo",
        context: "normal"
      },
      {
        keys: "u",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: true
        },
        context: "visual",
        isEdit: true
      },
      {
        keys: "U",
        type: "operator",
        operator: "changeCase",
        operatorArgs: {
          toLower: false
        },
        context: "visual",
        isEdit: true
      },
      {
        keys: "<C-r>",
        type: "action",
        action: "redo"
      },
      {
        keys: "m<character>",
        type: "action",
        action: "setMark"
      },
      {
        keys: '"<character>',
        type: "action",
        action: "setRegister"
      },
      {
        keys: "zz",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "center"
        }
      },
      {
        keys: "z.",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "center"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "zt",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "top"
        }
      },
      {
        keys: "z<CR>",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "top"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: "z-",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "bottom"
        }
      },
      {
        keys: "zb",
        type: "action",
        action: "scrollToCursor",
        actionArgs: {
          position: "bottom"
        },
        motion: "moveToFirstNonWhiteSpaceCharacter"
      },
      {
        keys: ".",
        type: "action",
        action: "repeatLastEdit"
      },
      {
        keys: "<C-a>",
        type: "action",
        action: "incrementNumberToken",
        isEdit: true,
        actionArgs: {
          increase: true,
          backtrack: false
        }
      },
      {
        keys: "<C-x>",
        type: "action",
        action: "incrementNumberToken",
        isEdit: true,
        actionArgs: {
          increase: false,
          backtrack: false
        }
      },
      {
        keys: "<C-t>",
        type: "action",
        action: "indent",
        actionArgs: {
          indentRight: true
        },
        context: "insert"
      },
      {
        keys: "<C-d>",
        type: "action",
        action: "indent",
        actionArgs: {
          indentRight: false
        },
        context: "insert"
      },
      // Text object motions
      {
        keys: "a<character>",
        type: "motion",
        motion: "textObjectManipulation"
      },
      {
        keys: "i<character>",
        type: "motion",
        motion: "textObjectManipulation",
        motionArgs: {
          textObjectInner: true
        }
      },
      // Search
      {
        keys: "/",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "prompt",
          toJumplist: true
        }
      },
      {
        keys: "?",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "prompt",
          toJumplist: true
        }
      },
      {
        keys: "*",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "wordUnderCursor",
          wholeWordOnly: true,
          toJumplist: true
        }
      },
      {
        keys: "#",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "wordUnderCursor",
          wholeWordOnly: true,
          toJumplist: true
        }
      },
      {
        keys: "g*",
        type: "search",
        searchArgs: {
          forward: true,
          querySrc: "wordUnderCursor",
          toJumplist: true
        }
      },
      {
        keys: "g#",
        type: "search",
        searchArgs: {
          forward: false,
          querySrc: "wordUnderCursor",
          toJumplist: true
        }
      },
      // Ex command
      {
        keys: ":",
        type: "ex"
      }
    ];
    var defaultKeymapLength = defaultKeymap.length;
    var defaultExCommandMap = [{
      name: "colorscheme",
      shortName: "colo"
    }, {
      name: "map"
    }, {
      name: "imap",
      shortName: "im"
    }, {
      name: "nmap",
      shortName: "nm"
    }, {
      name: "vmap",
      shortName: "vm"
    }, {
      name: "unmap"
    }, {
      name: "write",
      shortName: "w"
    }, {
      name: "undo",
      shortName: "u"
    }, {
      name: "redo",
      shortName: "red"
    }, {
      name: "set",
      shortName: "se"
    }, {
      name: "setlocal",
      shortName: "setl"
    }, {
      name: "setglobal",
      shortName: "setg"
    }, {
      name: "sort",
      shortName: "sor"
    }, {
      name: "substitute",
      shortName: "s",
      possiblyAsync: true
    }, {
      name: "nohlsearch",
      shortName: "noh"
    }, {
      name: "yank",
      shortName: "y"
    }, {
      name: "delmarks",
      shortName: "delm"
    }, {
      name: "registers",
      shortName: "reg",
      excludeFromCommandHistory: true
    }, {
      name: "vglobal",
      shortName: "v"
    }, {
      name: "global",
      shortName: "g"
    }];
    var Vim = exports.Vim = function Vim2() {
      function enterVimMode(cm) {
        cm.setOption("disableInput", true);
        cm.setOption("showCursorWhenSelecting", false);
        _cm_adapter["default"].signal(cm, "vim-mode-change", {
          mode: "normal"
        });
        cm.on("cursorActivity", onCursorActivity);
        maybeInitVimState(cm);
        cm.enterVimMode();
      }
      function leaveVimMode(cm) {
        cm.setOption("disableInput", false);
        cm.off("cursorActivity", onCursorActivity);
        cm.state.vim = null;
        if (highlightTimeout) clearTimeout(highlightTimeout);
        cm.leaveVimMode();
      }
      function detachVimMap(cm, next) {
        cm.attached = false;
        if (this == _cm_adapter["default"].keyMap.vim) {
          cm.options.$customCursor = null;
        }
        if (!next || next.attach != attachVimMap) leaveVimMode(cm);
      }
      function attachVimMap(cm, prev) {
        if (this == _cm_adapter["default"].keyMap.vim) {
          cm.attached = true;
          if (cm.curOp) cm.curOp.selectionChanged = true;
          cm.options.$customCursor = transformCursor;
        }
        if (!prev || prev.attach != attachVimMap) enterVimMode(cm);
      }
      _cm_adapter["default"].defineOption("vimMode", false, function(cm, val, prev) {
        if (val && cm.getOption("keyMap") != "vim") cm.setOption("keyMap", "vim");
        else if (!val && prev != _cm_adapter["default"].Init && /^vim/.test(cm.getOption("keyMap"))) cm.setOption("keyMap", "default");
      });
      function cmKey(key, cm) {
        if (!cm) {
          return void 0;
        }
        if (this[key]) {
          return this[key];
        }
        var vimKey = cmKeyToVimKey(key);
        if (!vimKey) {
          return false;
        }
        var cmd = vimApi.findKey(cm, vimKey);
        if (typeof cmd == "function") {
          _cm_adapter["default"].signal(cm, "vim-keypress", vimKey);
        }
        return cmd;
      }
      var modifiers = {
        Shift: "S",
        Ctrl: "C",
        Alt: "A",
        Cmd: "D",
        Mod: "A",
        CapsLock: ""
      };
      var specialKeys = {
        Enter: "CR",
        Backspace: "BS",
        Delete: "Del",
        Insert: "Ins"
      };
      function cmKeyToVimKey(key) {
        if (key.charAt(0) == "'") {
          return key.charAt(1);
        }
        if (key === "AltGraph") {
          return false;
        }
        var pieces = key.split(/-(?!$)/);
        var lastPiece = pieces[pieces.length - 1];
        if (pieces.length == 1 && pieces[0].length == 1) {
          return false;
        } else if (pieces.length == 2 && pieces[0] == "Shift" && lastPiece.length == 1) {
          return false;
        }
        var hasCharacter = false;
        for (var i = 0; i < pieces.length; i++) {
          var piece = pieces[i];
          if (piece in modifiers) {
            pieces[i] = modifiers[piece];
          } else {
            hasCharacter = true;
          }
          if (piece in specialKeys) {
            pieces[i] = specialKeys[piece];
          }
        }
        if (!hasCharacter) {
          return false;
        }
        if (isUpperCase(lastPiece)) {
          pieces[pieces.length - 1] = lastPiece.toLowerCase();
        }
        return "<" + pieces.join("-") + ">";
      }
      var numberRegex = /[\d]/;
      var wordCharTest = [_cm_adapter["default"].isWordChar, function(ch) {
        return ch && !_cm_adapter["default"].isWordChar(ch) && !/\s/.test(ch);
      }], bigWordCharTest = [function(ch) {
        return /\S/.test(ch);
      }];
      function makeKeyRange(start, size) {
        var keys = [];
        for (var i = start; i < start + size; i++) {
          keys.push(String.fromCharCode(i));
        }
        return keys;
      }
      var upperCaseAlphabet = makeKeyRange(65, 26);
      var lowerCaseAlphabet = makeKeyRange(97, 26);
      var numbers = makeKeyRange(48, 10);
      var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ["<", ">"]);
      var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ["-", '"', ".", ":", "_", "/"]);
      var upperCaseChars;
      try {
        upperCaseChars = new RegExp("^[\\p{Lu}]$", "u");
      } catch (_) {
        upperCaseChars = /^[A-Z]$/;
      }
      function isLine(cm, line) {
        return line >= cm.firstLine() && line <= cm.lastLine();
      }
      function isLowerCase(k) {
        return /^[a-z]$/.test(k);
      }
      function isMatchableSymbol(k) {
        return "()[]{}".indexOf(k) != -1;
      }
      function isNumber(k) {
        return numberRegex.test(k);
      }
      function isUpperCase(k) {
        return upperCaseChars.test(k);
      }
      function isWhiteSpaceString(k) {
        return /^\s*$/.test(k);
      }
      function isEndOfSentenceSymbol(k) {
        return ".?!".indexOf(k) != -1;
      }
      function inArray(val, arr) {
        for (var i = 0; i < arr.length; i++) {
          if (arr[i] == val) {
            return true;
          }
        }
        return false;
      }
      var options = {};
      function defineOption(name, defaultValue, type, aliases, callback) {
        if (defaultValue === void 0 && !callback) {
          throw Error("defaultValue is required unless callback is provided");
        }
        if (!type) {
          type = "string";
        }
        options[name] = {
          type,
          defaultValue,
          callback
        };
        if (aliases) {
          for (var i = 0; i < aliases.length; i++) {
            options[aliases[i]] = options[name];
          }
        }
        if (defaultValue) {
          setOption(name, defaultValue);
        }
      }
      function setOption(name, value, cm, cfg) {
        var option = options[name];
        cfg = cfg || {};
        var scope = cfg.scope;
        if (!option) {
          return new Error("Unknown option: " + name);
        }
        if (option.type == "boolean") {
          if (value && value !== true) {
            return new Error("Invalid argument: " + name + "=" + value);
          } else if (value !== false) {
            value = true;
          }
        }
        if (option.callback) {
          if (scope !== "local") {
            option.callback(value, void 0);
          }
          if (scope !== "global" && cm) {
            option.callback(value, cm);
          }
        } else {
          if (scope !== "local") {
            option.value = option.type == "boolean" ? !!value : value;
          }
          if (scope !== "global" && cm) {
            cm.state.vim.options[name] = {
              value
            };
          }
        }
      }
      function getOption(name, cm, cfg) {
        var option = options[name];
        cfg = cfg || {};
        var scope = cfg.scope;
        if (!option) {
          return new Error("Unknown option: " + name);
        }
        if (option.callback) {
          var local = cm && option.callback(void 0, cm);
          if (scope !== "global" && local !== void 0) {
            return local;
          }
          if (scope !== "local") {
            return option.callback();
          }
          return;
        } else {
          var local = scope !== "global" && cm && cm.state.vim.options[name];
          return (local || scope !== "local" && option || {}).value;
        }
      }
      defineOption("filetype", void 0, "string", ["ft"], function(name, cm) {
        if (cm === void 0) {
          return;
        }
        if (name === void 0) {
          var mode = cm.getOption("mode");
          return mode == "null" ? "" : mode;
        } else {
          var mode = name == "" ? "null" : name;
          cm.setOption("mode", mode);
        }
      });
      var createCircularJumpList = function createCircularJumpList2() {
        var size = 100;
        var pointer = -1;
        var head = 0;
        var tail = 0;
        var buffer = new Array(size);
        function add(cm, oldCur, newCur) {
          var current = pointer % size;
          var curMark = buffer[current];
          function useNextSlot(cursor) {
            var next = ++pointer % size;
            var trashMark = buffer[next];
            if (trashMark) {
              trashMark.clear();
            }
            buffer[next] = cm.setBookmark(cursor);
          }
          if (curMark) {
            var markPos = curMark.find();
            if (markPos && !cursorEqual(markPos, oldCur)) {
              useNextSlot(oldCur);
            }
          } else {
            useNextSlot(oldCur);
          }
          useNextSlot(newCur);
          head = pointer;
          tail = pointer - size + 1;
          if (tail < 0) {
            tail = 0;
          }
        }
        function move(cm, offset) {
          pointer += offset;
          if (pointer > head) {
            pointer = head;
          } else if (pointer < tail) {
            pointer = tail;
          }
          var mark = buffer[(size + pointer) % size];
          if (mark && !mark.find()) {
            var inc = offset > 0 ? 1 : -1;
            var newCur;
            var oldCur = cm.getCursor();
            do {
              pointer += inc;
              mark = buffer[(size + pointer) % size];
              if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {
                break;
              }
            } while (pointer < head && pointer > tail);
          }
          return mark;
        }
        function find(cm, offset) {
          var oldPointer = pointer;
          var mark = move(cm, offset);
          pointer = oldPointer;
          return mark && mark.find();
        }
        return {
          cachedCursor: void 0,
          //used for # and * jumps
          add,
          find,
          move
        };
      };
      var createInsertModeChanges = function createInsertModeChanges2(c) {
        if (c) {
          return {
            changes: c.changes,
            expectCursorActivityForChange: c.expectCursorActivityForChange
          };
        }
        return {
          // Change list
          changes: [],
          // Set to true on change, false on cursorActivity.
          expectCursorActivityForChange: false
        };
      };
      function MacroModeState() {
        this.latestRegister = void 0;
        this.isPlaying = false;
        this.isRecording = false;
        this.replaySearchQueries = [];
        this.onRecordingDone = void 0;
        this.lastInsertModeChanges = createInsertModeChanges();
      }
      MacroModeState.prototype = {
        exitMacroRecordMode: function exitMacroRecordMode() {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.onRecordingDone) {
            macroModeState.onRecordingDone();
          }
          macroModeState.onRecordingDone = void 0;
          macroModeState.isRecording = false;
        },
        enterMacroRecordMode: function enterMacroRecordMode(cm, registerName) {
          var register = vimGlobalState.registerController.getRegister(registerName);
          if (register) {
            register.clear();
            this.latestRegister = registerName;
            if (cm.openDialog) {
              this.onRecordingDone = cm.openDialog(document.createTextNode("(recording)[" + registerName + "]"), null, {
                bottom: true
              });
            }
            this.isRecording = true;
          }
        }
      };
      function maybeInitVimState(cm) {
        if (!cm.state.vim) {
          cm.state.vim = {
            inputState: new InputState(),
            // Vim's input state that triggered the last edit, used to repeat
            // motions and operators with '.'.
            lastEditInputState: void 0,
            // Vim's action command before the last edit, used to repeat actions
            // with '.' and insert mode repeat.
            lastEditActionCommand: void 0,
            // When using jk for navigation, if you move from a longer line to a
            // shorter line, the cursor may clip to the end of the shorter line.
            // If j is pressed again and cursor goes to the next line, the
            // cursor should go back to its horizontal position on the longer
            // line if it can. This is to keep track of the horizontal position.
            lastHPos: -1,
            // Doing the same with screen-position for gj/gk
            lastHSPos: -1,
            // The last motion command run. Cleared if a non-motion command gets
            // executed in between.
            lastMotion: null,
            marks: {},
            insertMode: false,
            // Repeat count for changes made in insert mode, triggered by key
            // sequences like 3,i. Only exists when insertMode is true.
            insertModeRepeat: void 0,
            visualMode: false,
            // If we are in visual line mode. No effect if visualMode is false.
            visualLine: false,
            visualBlock: false,
            lastSelection: null,
            lastPastedText: null,
            sel: {},
            // Buffer-local/window-local values of vim options.
            options: {}
          };
        }
        return cm.state.vim;
      }
      var vimGlobalState;
      function resetVimGlobalState() {
        vimGlobalState = {
          // The current search query.
          searchQuery: null,
          // Whether we are searching backwards.
          searchIsReversed: false,
          // Replace part of the last substituted pattern
          lastSubstituteReplacePart: void 0,
          jumpList: createCircularJumpList(),
          macroModeState: new MacroModeState(),
          // Recording latest f, t, F or T motion command.
          lastCharacterSearch: {
            increment: 0,
            forward: true,
            selectedCharacter: ""
          },
          registerController: new RegisterController({}),
          // search history buffer
          searchHistoryController: new HistoryController(),
          // ex Command history buffer
          exCommandHistoryController: new HistoryController()
        };
        for (var optionName in options) {
          var option = options[optionName];
          option.value = option.defaultValue;
        }
      }
      var lastInsertModeKeyTimer;
      var vimApi = {
        buildKeyMap: function buildKeyMap() {
        },
        // Testing hook, though it might be useful to expose the register
        // controller anyway.
        getRegisterController: function getRegisterController() {
          return vimGlobalState.registerController;
        },
        // Testing hook.
        resetVimGlobalState_: resetVimGlobalState,
        // Testing hook.
        getVimGlobalState_: function getVimGlobalState_() {
          return vimGlobalState;
        },
        // Testing hook.
        maybeInitVimState_: maybeInitVimState,
        suppressErrorLogging: false,
        InsertModeKey,
        map: function map(lhs, rhs, ctx) {
          exCommandDispatcher.map(lhs, rhs, ctx);
        },
        unmap: function unmap(lhs, ctx) {
          return exCommandDispatcher.unmap(lhs, ctx);
        },
        // Non-recursive map function.
        // NOTE: This will not create mappings to key maps that aren't present
        // in the default key map. See TODO at bottom of function.
        noremap: function noremap(lhs, rhs, ctx) {
          function toCtxArray(ctx2) {
            return ctx2 ? [ctx2] : ["normal", "insert", "visual"];
          }
          var ctxsToMap = toCtxArray(ctx);
          var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
          for (var i = actualLength - origLength; i < actualLength && ctxsToMap.length; i++) {
            var mapping = defaultKeymap[i];
            if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== "ex" && mapping.type.substr(0, 3) !== "key") {
              var newMapping = {};
              for (var key in mapping) {
                newMapping[key] = mapping[key];
              }
              newMapping.keys = lhs;
              if (ctx && !newMapping.context) {
                newMapping.context = ctx;
              }
              this._mapCommand(newMapping);
              var mappedCtxs = toCtxArray(mapping.context);
              ctxsToMap = ctxsToMap.filter(function(el) {
                return mappedCtxs.indexOf(el) === -1;
              });
            }
          }
        },
        // Remove all user-defined mappings for the provided context.
        mapclear: function mapclear(ctx) {
          var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
          var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
          defaultKeymap = defaultKeymap.slice(actualLength - origLength);
          if (ctx) {
            for (var i = userKeymap.length - 1; i >= 0; i--) {
              var mapping = userKeymap[i];
              if (ctx !== mapping.context) {
                if (mapping.context) {
                  this._mapCommand(mapping);
                } else {
                  var contexts = ["normal", "insert", "visual"];
                  for (var j in contexts) {
                    if (contexts[j] !== ctx) {
                      var newMapping = {};
                      for (var key in mapping) {
                        newMapping[key] = mapping[key];
                      }
                      newMapping.context = contexts[j];
                      this._mapCommand(newMapping);
                    }
                  }
                }
              }
            }
          }
        },
        // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace
        // them, or somehow make them work with the existing CodeMirror setOption/getOption API.
        setOption,
        getOption,
        defineOption,
        defineEx: function defineEx(name, prefix, func) {
          if (!prefix) {
            prefix = name;
          } else if (name.indexOf(prefix) !== 0) {
            throw new Error('(Vim.defineEx) "' + prefix + '" is not a prefix of "' + name + '", command not registered');
          }
          exCommands[name] = func;
          exCommandDispatcher.commandMap_[prefix] = {
            name,
            shortName: prefix,
            type: "api"
          };
        },
        handleKey: function handleKey(cm, key, origin) {
          var command = this.findKey(cm, key, origin);
          if (typeof command === "function") {
            return command();
          }
        },
        /**
         * This is the outermost function called by CodeMirror, after keys have
         * been mapped to their Vim equivalents.
         *
         * Finds a command based on the key (and cached keys if there is a
         * multi-key sequence). Returns `undefined` if no key is matched, a noop
         * function if a partial match is found (multi-key), and a function to
         * execute the bound command if a a key is matched. The function always
         * returns true.
         */
        findKey: function findKey(cm, key, origin) {
          var vim = maybeInitVimState(cm);
          function handleMacroRecording() {
            var macroModeState = vimGlobalState.macroModeState;
            if (macroModeState.isRecording) {
              if (key == "q") {
                macroModeState.exitMacroRecordMode();
                clearInputState(cm);
                return true;
              }
              if (origin != "mapping") {
                logKey(macroModeState, key);
              }
            }
          }
          function handleEsc() {
            if (key == "<Esc>") {
              if (vim.visualMode) {
                exitVisualMode(cm);
              } else if (vim.insertMode) {
                exitInsertMode(cm);
              } else {
                return;
              }
              clearInputState(cm);
              return true;
            }
          }
          function doKeyToKey(keys) {
            var match;
            while (keys) {
              match = /<\w+-.+?>|<\w+>|./.exec(keys);
              key = match[0];
              keys = keys.substring(match.index + key.length);
              vimApi.handleKey(cm, key, "mapping");
            }
          }
          function handleKeyInsertMode() {
            if (handleEsc()) {
              return true;
            }
            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
            var keysAreChars = key.length == 1;
            var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, "insert");
            while (keys.length > 1 && match.type != "full") {
              var keys = vim.inputState.keyBuffer = keys.slice(1);
              var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, "insert");
              if (thisMatch.type != "none") {
                match = thisMatch;
              }
            }
            if (match.type == "none") {
              clearInputState(cm);
              return false;
            } else if (match.type == "partial") {
              if (lastInsertModeKeyTimer) {
                window.clearTimeout(lastInsertModeKeyTimer);
              }
              lastInsertModeKeyTimer = window.setTimeout(function() {
                if (vim.insertMode && vim.inputState.keyBuffer) {
                  clearInputState(cm);
                }
              }, getOption("insertModeEscKeysTimeout"));
              return !keysAreChars;
            }
            if (lastInsertModeKeyTimer) {
              window.clearTimeout(lastInsertModeKeyTimer);
            }
            if (keysAreChars) {
              var selections = cm.listSelections();
              for (var i = 0; i < selections.length; i++) {
                var here = selections[i].head;
                cm.replaceRange("", offsetCursor(here, 0, -(keys.length - 1)), here, "+input");
              }
              vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
            }
            clearInputState(cm);
            return match.command;
          }
          function handleKeyNonInsertMode() {
            if (handleMacroRecording() || handleEsc()) {
              return true;
            }
            var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
            if (/^[1-9]\d*$/.test(keys)) {
              return true;
            }
            var keysMatcher = /^(\d*)(.*)$/.exec(keys);
            if (!keysMatcher) {
              clearInputState(cm);
              return false;
            }
            var context = vim.visualMode ? "visual" : "normal";
            var mainKey = keysMatcher[2] || keysMatcher[1];
            if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) {
              mainKey = vim.inputState.operatorShortcut;
            }
            var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);
            if (match.type == "none") {
              clearInputState(cm);
              return false;
            } else if (match.type == "partial") {
              return true;
            }
            vim.inputState.keyBuffer = "";
            var keysMatcher = /^(\d*)(.*)$/.exec(keys);
            if (keysMatcher[1] && keysMatcher[1] != "0") {
              vim.inputState.pushRepeatDigit(keysMatcher[1]);
            }
            return match.command;
          }
          var command;
          if (vim.insertMode) {
            command = handleKeyInsertMode();
          } else {
            command = handleKeyNonInsertMode();
          }
          if (command === false) {
            return !vim.insertMode && key.length === 1 ? function() {
              return true;
            } : void 0;
          } else if (command === true) {
            return function() {
              return true;
            };
          } else {
            return function() {
              return cm.operation(function() {
                cm.curOp.isVimOp = true;
                try {
                  if (command.type == "keyToKey") {
                    doKeyToKey(command.toKeys);
                  } else {
                    commandDispatcher.processCommand(cm, vim, command);
                  }
                } catch (e) {
                  cm.state.vim = void 0;
                  maybeInitVimState(cm);
                  if (!vimApi.suppressErrorLogging) {
                    console["log"](e);
                  }
                  throw e;
                }
                return true;
              });
            };
          }
        },
        handleEx: function handleEx(cm, input) {
          exCommandDispatcher.processCommand(cm, input);
        },
        defineMotion,
        defineAction,
        defineOperator,
        mapCommand,
        _mapCommand,
        defineRegister,
        exitVisualMode,
        exitInsertMode
      };
      function InputState() {
        this.prefixRepeat = [];
        this.motionRepeat = [];
        this.operator = null;
        this.operatorArgs = null;
        this.motion = null;
        this.motionArgs = null;
        this.keyBuffer = [];
        this.registerName = null;
      }
      InputState.prototype.pushRepeatDigit = function(n) {
        if (!this.operator) {
          this.prefixRepeat = this.prefixRepeat.concat(n);
        } else {
          this.motionRepeat = this.motionRepeat.concat(n);
        }
      };
      InputState.prototype.getRepeat = function() {
        var repeat = 0;
        if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
          repeat = 1;
          if (this.prefixRepeat.length > 0) {
            repeat *= parseInt(this.prefixRepeat.join(""), 10);
          }
          if (this.motionRepeat.length > 0) {
            repeat *= parseInt(this.motionRepeat.join(""), 10);
          }
        }
        return repeat;
      };
      function clearInputState(cm, reason) {
        cm.state.vim.inputState = new InputState();
        _cm_adapter["default"].signal(cm, "vim-command-done", reason);
      }
      function Register(text, linewise, blockwise) {
        this.clear();
        this.keyBuffer = [text || ""];
        this.insertModeChanges = [];
        this.searchQueries = [];
        this.linewise = !!linewise;
        this.blockwise = !!blockwise;
      }
      Register.prototype = {
        setText: function setText(text, linewise, blockwise) {
          this.keyBuffer = [text || ""];
          this.linewise = !!linewise;
          this.blockwise = !!blockwise;
        },
        pushText: function pushText(text, linewise) {
          if (linewise) {
            if (!this.linewise) {
              this.keyBuffer.push("\n");
            }
            this.linewise = true;
          }
          this.keyBuffer.push(text);
        },
        pushInsertModeChanges: function pushInsertModeChanges(changes) {
          this.insertModeChanges.push(createInsertModeChanges(changes));
        },
        pushSearchQuery: function pushSearchQuery(query) {
          this.searchQueries.push(query);
        },
        clear: function clear() {
          this.keyBuffer = [];
          this.insertModeChanges = [];
          this.searchQueries = [];
          this.linewise = false;
        },
        toString: function toString() {
          return this.keyBuffer.join("");
        }
      };
      function defineRegister(name, register) {
        var registers = vimGlobalState.registerController.registers;
        if (!name || name.length != 1) {
          throw Error("Register name must be 1 character");
        }
        if (registers[name]) {
          throw Error("Register already defined " + name);
        }
        registers[name] = register;
        validRegisters.push(name);
      }
      function RegisterController(registers) {
        this.registers = registers;
        this.unnamedRegister = registers['"'] = new Register();
        registers["."] = new Register();
        registers[":"] = new Register();
        registers["/"] = new Register();
      }
      RegisterController.prototype = {
        pushText: function pushText(registerName, operator, text, linewise, blockwise) {
          if (registerName === "_") return;
          if (linewise && text.charAt(text.length - 1) !== "\n") {
            text += "\n";
          }
          var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;
          if (!register) {
            switch (operator) {
              case "yank":
                this.registers["0"] = new Register(text, linewise, blockwise);
                break;
              case "delete":
              case "change":
                if (text.indexOf("\n") == -1) {
                  this.registers["-"] = new Register(text, linewise);
                } else {
                  this.shiftNumericRegisters_();
                  this.registers["1"] = new Register(text, linewise);
                }
                break;
            }
            this.unnamedRegister.setText(text, linewise, blockwise);
            return;
          }
          var append = isUpperCase(registerName);
          if (append) {
            register.pushText(text, linewise);
          } else {
            register.setText(text, linewise, blockwise);
          }
          this.unnamedRegister.setText(register.toString(), linewise);
        },
        // Gets the register named @name.  If one of @name doesn't already exist,
        // create it.  If @name is invalid, return the unnamedRegister.
        getRegister: function getRegister(name) {
          if (!this.isValidRegister(name)) {
            return this.unnamedRegister;
          }
          name = name.toLowerCase();
          if (!this.registers[name]) {
            this.registers[name] = new Register();
          }
          return this.registers[name];
        },
        isValidRegister: function isValidRegister(name) {
          return name && inArray(name, validRegisters);
        },
        shiftNumericRegisters_: function shiftNumericRegisters_() {
          for (var i = 9; i >= 2; i--) {
            this.registers[i] = this.getRegister("" + (i - 1));
          }
        }
      };
      function HistoryController() {
        this.historyBuffer = [];
        this.iterator = 0;
        this.initialPrefix = null;
      }
      HistoryController.prototype = {
        // the input argument here acts a user entered prefix for a small time
        // until we start autocompletion in which case it is the autocompleted.
        nextMatch: function nextMatch(input, up) {
          var historyBuffer = this.historyBuffer;
          var dir = up ? -1 : 1;
          if (this.initialPrefix === null) this.initialPrefix = input;
          for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {
            var element = historyBuffer[i];
            for (var j = 0; j <= element.length; j++) {
              if (this.initialPrefix == element.substring(0, j)) {
                this.iterator = i;
                return element;
              }
            }
          }
          if (i >= historyBuffer.length) {
            this.iterator = historyBuffer.length;
            return this.initialPrefix;
          }
          if (i < 0) return input;
        },
        pushInput: function pushInput(input) {
          var index = this.historyBuffer.indexOf(input);
          if (index > -1) this.historyBuffer.splice(index, 1);
          if (input.length) this.historyBuffer.push(input);
        },
        reset: function reset() {
          this.initialPrefix = null;
          this.iterator = this.historyBuffer.length;
        }
      };
      var commandDispatcher = {
        matchCommand: function matchCommand(keys, keyMap, inputState, context) {
          var matches = commandMatches(keys, keyMap, context, inputState);
          if (!matches.full && !matches.partial) {
            return {
              type: "none"
            };
          } else if (!matches.full && matches.partial) {
            return {
              type: "partial"
            };
          }
          var bestMatch;
          for (var i = 0; i < matches.full.length; i++) {
            var match = matches.full[i];
            if (!bestMatch) {
              bestMatch = match;
            }
          }
          if (bestMatch.keys.slice(-11) == "<character>") {
            var character = lastChar(keys);
            if (!character) return {
              type: "none"
            };
            inputState.selectedCharacter = character;
          }
          return {
            type: "full",
            command: bestMatch
          };
        },
        processCommand: function processCommand(cm, vim, command) {
          vim.inputState.repeatOverride = command.repeatOverride;
          switch (command.type) {
            case "motion":
              this.processMotion(cm, vim, command);
              break;
            case "operator":
              this.processOperator(cm, vim, command);
              break;
            case "operatorMotion":
              this.processOperatorMotion(cm, vim, command);
              break;
            case "action":
              this.processAction(cm, vim, command);
              break;
            case "search":
              this.processSearch(cm, vim, command);
              break;
            case "ex":
            case "keyToEx":
              this.processEx(cm, vim, command);
              break;
            default:
              break;
          }
        },
        processMotion: function processMotion(cm, vim, command) {
          vim.inputState.motion = command.motion;
          vim.inputState.motionArgs = copyArgs(command.motionArgs);
          this.evalInput(cm, vim);
        },
        processOperator: function processOperator(cm, vim, command) {
          var inputState = vim.inputState;
          if (inputState.operator) {
            if (inputState.operator == command.operator) {
              inputState.motion = "expandToLine";
              inputState.motionArgs = {
                linewise: true
              };
              this.evalInput(cm, vim);
              return;
            } else {
              clearInputState(cm);
            }
          }
          inputState.operator = command.operator;
          inputState.operatorArgs = copyArgs(command.operatorArgs);
          if (command.keys.length > 1) {
            inputState.operatorShortcut = command.keys;
          }
          if (command.exitVisualBlock) {
            vim.visualBlock = false;
            updateCmSelection(cm);
          }
          if (vim.visualMode) {
            this.evalInput(cm, vim);
          }
        },
        processOperatorMotion: function processOperatorMotion(cm, vim, command) {
          var visualMode = vim.visualMode;
          var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
          if (operatorMotionArgs) {
            if (visualMode && operatorMotionArgs.visualLine) {
              vim.visualLine = true;
            }
          }
          this.processOperator(cm, vim, command);
          if (!visualMode) {
            this.processMotion(cm, vim, command);
          }
        },
        processAction: function processAction(cm, vim, command) {
          var inputState = vim.inputState;
          var repeat = inputState.getRepeat();
          var repeatIsExplicit = !!repeat;
          var actionArgs = copyArgs(command.actionArgs) || {};
          if (inputState.selectedCharacter) {
            actionArgs.selectedCharacter = inputState.selectedCharacter;
          }
          if (command.operator) {
            this.processOperator(cm, vim, command);
          }
          if (command.motion) {
            this.processMotion(cm, vim, command);
          }
          if (command.motion || command.operator) {
            this.evalInput(cm, vim);
          }
          actionArgs.repeat = repeat || 1;
          actionArgs.repeatIsExplicit = repeatIsExplicit;
          actionArgs.registerName = inputState.registerName;
          clearInputState(cm);
          vim.lastMotion = null;
          if (command.isEdit) {
            this.recordLastEdit(vim, inputState, command);
          }
          actions[command.action](cm, actionArgs, vim);
        },
        processSearch: function processSearch(cm, vim, command) {
          if (!cm.getSearchCursor) {
            return;
          }
          var forward = command.searchArgs.forward;
          var wholeWordOnly = command.searchArgs.wholeWordOnly;
          getSearchState(cm).setReversed(!forward);
          var promptPrefix = forward ? "/" : "?";
          var originalQuery = getSearchState(cm).getQuery();
          var originalScrollPos = cm.getScrollInfo();
          function handleQuery(query2, ignoreCase, smartCase) {
            vimGlobalState.searchHistoryController.pushInput(query2);
            vimGlobalState.searchHistoryController.reset();
            try {
              updateSearchQuery(cm, query2, ignoreCase, smartCase);
            } catch (e) {
              showConfirm(cm, "Invalid regex: " + query2);
              clearInputState(cm);
              return;
            }
            commandDispatcher.processMotion(cm, vim, {
              type: "motion",
              motion: "findNext",
              motionArgs: {
                forward: true,
                toJumplist: command.searchArgs.toJumplist
              }
            });
          }
          function onPromptClose(query2) {
            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            handleQuery(
              query2,
              true,
              true
              /** smartCase */
            );
            var macroModeState2 = vimGlobalState.macroModeState;
            if (macroModeState2.isRecording) {
              logSearchQuery(macroModeState2, query2);
            }
          }
          function onPromptKeyUp(e, query2, close) {
            var keyName = _cm_adapter["default"].keyName(e), up, offset;
            if (keyName == "Up" || keyName == "Down") {
              up = keyName == "Up" ? true : false;
              offset = e.target ? e.target.selectionEnd : 0;
              query2 = vimGlobalState.searchHistoryController.nextMatch(query2, up) || "";
              close(query2);
              if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
            } else {
              if (keyName != "Left" && keyName != "Right" && keyName != "Ctrl" && keyName != "Alt" && keyName != "Shift") vimGlobalState.searchHistoryController.reset();
            }
            var parsedQuery;
            try {
              parsedQuery = updateSearchQuery(
                cm,
                query2,
                true,
                true
                /** smartCase */
              );
            } catch (e2) {
            }
            if (parsedQuery) {
              cm.scrollIntoView(_findNext(cm, !forward, parsedQuery), 30);
            } else {
              clearSearchHighlight(cm);
              cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
            }
          }
          function onPromptKeyDown(e, query2, close) {
            var keyName = _cm_adapter["default"].keyName(e);
            if (keyName == "Esc" || keyName == "Ctrl-C" || keyName == "Ctrl-[" || keyName == "Backspace" && query2 == "") {
              vimGlobalState.searchHistoryController.pushInput(query2);
              vimGlobalState.searchHistoryController.reset();
              updateSearchQuery(cm, originalQuery);
              clearSearchHighlight(cm);
              cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
              _cm_adapter["default"].e_stop(e);
              clearInputState(cm);
              close();
              cm.focus();
            } else if (keyName == "Up" || keyName == "Down") {
              _cm_adapter["default"].e_stop(e);
            } else if (keyName == "Ctrl-U") {
              _cm_adapter["default"].e_stop(e);
              close("");
            }
          }
          switch (command.searchArgs.querySrc) {
            case "prompt":
              var macroModeState = vimGlobalState.macroModeState;
              if (macroModeState.isPlaying) {
                var query = macroModeState.replaySearchQueries.shift();
                handleQuery(
                  query,
                  true,
                  false
                  /** smartCase */
                );
              } else {
                showPrompt(cm, {
                  onClose: onPromptClose,
                  prefix: promptPrefix,
                  desc: "(JavaScript regexp)",
                  onKeyUp: onPromptKeyUp,
                  onKeyDown: onPromptKeyDown
                });
              }
              break;
            case "wordUnderCursor":
              var word = expandWordUnderCursor(
                cm,
                false,
                true,
                false,
                true
                /** noSymbol */
              );
              var isKeyword = true;
              if (!word) {
                word = expandWordUnderCursor(
                  cm,
                  false,
                  true,
                  false,
                  false
                  /** noSymbol */
                );
                isKeyword = false;
              }
              if (!word) {
                return;
              }
              var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);
              if (isKeyword && wholeWordOnly) {
                query = "\\b" + query + "\\b";
              } else {
                query = escapeRegex(query);
              }
              vimGlobalState.jumpList.cachedCursor = cm.getCursor();
              cm.setCursor(word.start);
              handleQuery(
                query,
                true,
                false
                /** smartCase */
              );
              break;
          }
        },
        processEx: function processEx(cm, vim, command) {
          function onPromptClose(input) {
            vimGlobalState.exCommandHistoryController.pushInput(input);
            vimGlobalState.exCommandHistoryController.reset();
            exCommandDispatcher.processCommand(cm, input);
          }
          function onPromptKeyDown(e, input, close) {
            var keyName = _cm_adapter["default"].keyName(e), up, offset;
            if (keyName == "Esc" || keyName == "Ctrl-C" || keyName == "Ctrl-[" || keyName == "Backspace" && input == "") {
              vimGlobalState.exCommandHistoryController.pushInput(input);
              vimGlobalState.exCommandHistoryController.reset();
              _cm_adapter["default"].e_stop(e);
              clearInputState(cm);
              close();
              cm.focus();
            }
            if (keyName == "Up" || keyName == "Down") {
              _cm_adapter["default"].e_stop(e);
              up = keyName == "Up" ? true : false;
              offset = e.target ? e.target.selectionEnd : 0;
              input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || "";
              close(input);
              if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
            } else if (keyName == "Ctrl-U") {
              _cm_adapter["default"].e_stop(e);
              close("");
            } else {
              if (keyName != "Left" && keyName != "Right" && keyName != "Ctrl" && keyName != "Alt" && keyName != "Shift") vimGlobalState.exCommandHistoryController.reset();
            }
          }
          if (command.type == "keyToEx") {
            exCommandDispatcher.processCommand(cm, command.exArgs.input);
          } else {
            if (vim.visualMode) {
              showPrompt(cm, {
                onClose: onPromptClose,
                prefix: ":",
                value: "'<,'>",
                onKeyDown: onPromptKeyDown,
                selectValueOnOpen: false
              });
            } else {
              showPrompt(cm, {
                onClose: onPromptClose,
                prefix: ":",
                onKeyDown: onPromptKeyDown
              });
            }
          }
        },
        evalInput: function evalInput(cm, vim) {
          var inputState = vim.inputState;
          var motion = inputState.motion;
          var motionArgs = inputState.motionArgs || {};
          var operator = inputState.operator;
          var operatorArgs = inputState.operatorArgs || {};
          var registerName = inputState.registerName;
          var sel = vim.sel;
          var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor("head"));
          var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor("anchor"));
          var oldHead = copyCursor(origHead);
          var oldAnchor = copyCursor(origAnchor);
          var newHead, newAnchor;
          var repeat;
          if (operator) {
            this.recordLastEdit(vim, inputState);
          }
          if (inputState.repeatOverride !== void 0) {
            repeat = inputState.repeatOverride;
          } else {
            repeat = inputState.getRepeat();
          }
          if (repeat > 0 && motionArgs.explicitRepeat) {
            motionArgs.repeatIsExplicit = true;
          } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {
            repeat = 1;
            motionArgs.repeatIsExplicit = false;
          }
          if (inputState.selectedCharacter) {
            motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;
          }
          motionArgs.repeat = repeat;
          clearInputState(cm);
          if (motion) {
            var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);
            vim.lastMotion = motions[motion];
            if (!motionResult) {
              return;
            }
            if (motionArgs.toJumplist) {
              var jumpList = vimGlobalState.jumpList;
              var cachedCursor = jumpList.cachedCursor;
              if (cachedCursor) {
                recordJumpPosition(cm, cachedCursor, motionResult);
                delete jumpList.cachedCursor;
              } else {
                recordJumpPosition(cm, origHead, motionResult);
              }
            }
            if (motionResult instanceof Array) {
              newAnchor = motionResult[0];
              newHead = motionResult[1];
            } else {
              newHead = motionResult;
            }
            if (!newHead) {
              newHead = copyCursor(origHead);
            }
            if (vim.visualMode) {
              if (!(vim.visualBlock && newHead.ch === Infinity)) {
                newHead = clipCursorToContent(cm, newHead);
              }
              if (newAnchor) {
                newAnchor = clipCursorToContent(cm, newAnchor);
              }
              newAnchor = newAnchor || oldAnchor;
              sel.anchor = newAnchor;
              sel.head = newHead;
              updateCmSelection(cm);
              updateMark(cm, vim, "<", cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);
              updateMark(cm, vim, ">", cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);
            } else if (!operator) {
              newHead = clipCursorToContent(cm, newHead);
              cm.setCursor(newHead.line, newHead.ch);
            }
          }
          if (operator) {
            if (operatorArgs.lastSel) {
              newAnchor = oldAnchor;
              var lastSel = operatorArgs.lastSel;
              var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
              var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
              if (lastSel.visualLine) {
                newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
              } else if (lastSel.visualBlock) {
                newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
              } else if (lastSel.head.line == lastSel.anchor.line) {
                newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);
              } else {
                newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
              }
              vim.visualMode = true;
              vim.visualLine = lastSel.visualLine;
              vim.visualBlock = lastSel.visualBlock;
              sel = vim.sel = {
                anchor: newAnchor,
                head: newHead
              };
              updateCmSelection(cm);
            } else if (vim.visualMode) {
              operatorArgs.lastSel = {
                anchor: copyCursor(sel.anchor),
                head: copyCursor(sel.head),
                visualBlock: vim.visualBlock,
                visualLine: vim.visualLine
              };
            }
            var curStart, curEnd, linewise, mode;
            var cmSel;
            if (vim.visualMode) {
              curStart = cursorMin(sel.head, sel.anchor);
              curEnd = cursorMax(sel.head, sel.anchor);
              linewise = vim.visualLine || operatorArgs.linewise;
              mode = vim.visualBlock ? "block" : linewise ? "line" : "char";
              cmSel = makeCmSelection(cm, {
                anchor: curStart,
                head: curEnd
              }, mode);
              if (linewise) {
                var ranges = cmSel.ranges;
                if (mode == "block") {
                  for (var i = 0; i < ranges.length; i++) {
                    ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
                  }
                } else if (mode == "line") {
                  ranges[0].head = new Pos(ranges[0].head.line + 1, 0);
                }
              }
            } else {
              curStart = copyCursor(newAnchor || oldAnchor);
              curEnd = copyCursor(newHead || oldHead);
              if (cursorIsBefore(curEnd, curStart)) {
                var tmp = curStart;
                curStart = curEnd;
                curEnd = tmp;
              }
              linewise = motionArgs.linewise || operatorArgs.linewise;
              if (linewise) {
                expandSelectionToLine(cm, curStart, curEnd);
              } else if (motionArgs.forward) {
                clipToLine(cm, curStart, curEnd);
              }
              mode = "char";
              var exclusive = !motionArgs.inclusive || linewise;
              cmSel = makeCmSelection(cm, {
                anchor: curStart,
                head: curEnd
              }, mode, exclusive);
            }
            cm.setSelections(cmSel.ranges, cmSel.primary);
            vim.lastMotion = null;
            operatorArgs.repeat = repeat;
            operatorArgs.registerName = registerName;
            operatorArgs.linewise = linewise;
            var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
            if (vim.visualMode) {
              exitVisualMode(cm, operatorMoveTo != null);
            }
            if (operatorMoveTo) {
              cm.setCursor(operatorMoveTo);
            }
          }
        },
        recordLastEdit: function recordLastEdit(vim, inputState, actionCommand) {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isPlaying) {
            return;
          }
          vim.lastEditInputState = inputState;
          vim.lastEditActionCommand = actionCommand;
          macroModeState.lastInsertModeChanges.changes = [];
          macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
          macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
        }
      };
      var motions = {
        moveToTopLine: function moveToTopLine(cm, _head, motionArgs) {
          var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;
          return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
        },
        moveToMiddleLine: function moveToMiddleLine(cm) {
          var range = getUserVisibleLines(cm);
          var line = Math.floor((range.top + range.bottom) * 0.5);
          return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
        },
        moveToBottomLine: function moveToBottomLine(cm, _head, motionArgs) {
          var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;
          return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
        },
        expandToLine: function expandToLine(_cm, head, motionArgs) {
          var cur = head;
          return new Pos(cur.line + motionArgs.repeat - 1, Infinity);
        },
        findNext: function findNext(cm, _head, motionArgs) {
          var state = getSearchState(cm);
          var query = state.getQuery();
          if (!query) {
            return;
          }
          var prev = !motionArgs.forward;
          prev = state.isReversed() ? !prev : prev;
          highlightSearchMatches(cm, query);
          return _findNext(cm, prev, query, motionArgs.repeat);
        },
        /**
         * Find and select the next occurrence of the search query. If the cursor is currently
         * within a match, then find and select the current match. Otherwise, find the next occurrence in the
         * appropriate direction.
         *
         * This differs from `findNext` in the following ways:
         *
         * 1. Instead of only returning the "from", this returns a "from", "to" range.
         * 2. If the cursor is currently inside a search match, this selects the current match
         *    instead of the next match.
         * 3. If there is no associated operator, this will turn on visual mode.
         */
        findAndSelectNextInclusive: function findAndSelectNextInclusive(cm, _head, motionArgs, vim, prevInputState) {
          var state = getSearchState(cm);
          var query = state.getQuery();
          if (!query) {
            return;
          }
          var prev = !motionArgs.forward;
          prev = state.isReversed() ? !prev : prev;
          var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);
          if (!next) {
            return;
          }
          if (prevInputState.operator) {
            return next;
          }
          var from = next[0];
          var to = new Pos(next[1].line, next[1].ch - 1);
          if (vim.visualMode) {
            if (vim.visualLine || vim.visualBlock) {
              vim.visualLine = false;
              vim.visualBlock = false;
              _cm_adapter["default"].signal(cm, "vim-mode-change", {
                mode: "visual",
                subMode: ""
              });
            }
            var anchor = vim.sel.anchor;
            if (anchor) {
              if (state.isReversed()) {
                if (motionArgs.forward) {
                  return [anchor, from];
                }
                return [anchor, to];
              } else {
                if (motionArgs.forward) {
                  return [anchor, to];
                }
                return [anchor, from];
              }
            }
          } else {
            vim.visualMode = true;
            vim.visualLine = false;
            vim.visualBlock = false;
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "visual",
              subMode: ""
            });
          }
          return prev ? [to, from] : [from, to];
        },
        goToMark: function goToMark(cm, _head, motionArgs, vim) {
          var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
          if (pos) {
            return motionArgs.linewise ? {
              line: pos.line,
              ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))
            } : pos;
          }
          return null;
        },
        moveToOtherHighlightedEnd: function moveToOtherHighlightedEnd(cm, _head, motionArgs, vim) {
          if (vim.visualBlock && motionArgs.sameLine) {
            var sel = vim.sel;
            return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];
          } else {
            return [vim.sel.head, vim.sel.anchor];
          }
        },
        jumpToMark: function jumpToMark(cm, head, motionArgs, vim) {
          var best = head;
          for (var i = 0; i < motionArgs.repeat; i++) {
            var cursor = best;
            for (var key in vim.marks) {
              if (!isLowerCase(key)) {
                continue;
              }
              var mark = vim.marks[key].find();
              var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);
              if (isWrongDirection) {
                continue;
              }
              if (motionArgs.linewise && mark.line == cursor.line) {
                continue;
              }
              var equal = cursorEqual(cursor, best);
              var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);
              if (equal || between) {
                best = mark;
              }
            }
          }
          if (motionArgs.linewise) {
            best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
          }
          return best;
        },
        moveByCharacters: function moveByCharacters(_cm, head, motionArgs) {
          var cur = head;
          var repeat = motionArgs.repeat;
          var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
          return new Pos(cur.line, ch);
        },
        moveByLines: function moveByLines(cm, head, motionArgs, vim) {
          var cur = head;
          var endCh = cur.ch;
          switch (vim.lastMotion) {
            case this.moveByLines:
            case this.moveByDisplayLines:
            case this.moveByScroll:
            case this.moveToColumn:
            case this.moveToEol:
              endCh = vim.lastHPos;
              break;
            default:
              vim.lastHPos = endCh;
          }
          var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);
          var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
          var first = cm.firstLine();
          var last = cm.lastLine();
          var posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, "line", vim.lastHSPos);
          var hasMarkedText = motionArgs.forward ? posV.line > line : posV.line < line;
          if (hasMarkedText) {
            line = posV.line;
            endCh = posV.ch;
          }
          if (line < first && cur.line == first) {
            return this.moveToStartOfLine(cm, head, motionArgs, vim);
          } else if (line > last && cur.line == last) {
            return _moveToEol(cm, head, motionArgs, vim, true);
          }
          if (motionArgs.toFirstChar) {
            endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));
            vim.lastHPos = endCh;
          }
          vim.lastHSPos = cm.charCoords(new Pos(line, endCh), "div").left;
          return new Pos(line, endCh);
        },
        moveByDisplayLines: function moveByDisplayLines(cm, head, motionArgs, vim) {
          var cur = head;
          switch (vim.lastMotion) {
            case this.moveByDisplayLines:
            case this.moveByScroll:
            case this.moveByLines:
            case this.moveToColumn:
            case this.moveToEol:
              break;
            default:
              vim.lastHSPos = cm.charCoords(cur, "div").left;
          }
          var repeat = motionArgs.repeat;
          var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, "line", vim.lastHSPos);
          if (res.hitSide) {
            if (motionArgs.forward) {
              var lastCharCoords = cm.charCoords(res, "div");
              var goalCoords = {
                top: lastCharCoords.top + 8,
                left: vim.lastHSPos
              };
              var res = cm.coordsChar(goalCoords, "div");
            } else {
              var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), "div");
              resCoords.left = vim.lastHSPos;
              res = cm.coordsChar(resCoords, "div");
            }
          }
          vim.lastHPos = res.ch;
          return res;
        },
        moveByPage: function moveByPage(cm, head, motionArgs) {
          var curStart = head;
          var repeat = motionArgs.repeat;
          return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, "page");
        },
        moveByParagraph: function moveByParagraph(cm, head, motionArgs) {
          var dir = motionArgs.forward ? 1 : -1;
          return findParagraph(cm, head, motionArgs.repeat, dir);
        },
        moveBySentence: function moveBySentence(cm, head, motionArgs) {
          var dir = motionArgs.forward ? 1 : -1;
          return findSentence(cm, head, motionArgs.repeat, dir);
        },
        moveByScroll: function moveByScroll(cm, head, motionArgs, vim) {
          var scrollbox = cm.getScrollInfo();
          var curEnd = null;
          var repeat = motionArgs.repeat;
          if (!repeat) {
            repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
          }
          var orig = cm.charCoords(head, "local");
          motionArgs.repeat = repeat;
          var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
          if (!curEnd) {
            return null;
          }
          var dest = cm.charCoords(curEnd, "local");
          cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
          return curEnd;
        },
        moveByWords: function moveByWords(cm, head, motionArgs) {
          return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);
        },
        moveTillCharacter: function moveTillCharacter(cm, _head, motionArgs) {
          var repeat = motionArgs.repeat;
          var curEnd = _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);
          var increment = motionArgs.forward ? -1 : 1;
          recordLastCharacterSearch(increment, motionArgs);
          if (!curEnd) return null;
          curEnd.ch += increment;
          return curEnd;
        },
        moveToCharacter: function moveToCharacter(cm, head, motionArgs) {
          var repeat = motionArgs.repeat;
          recordLastCharacterSearch(0, motionArgs);
          return _moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
        },
        moveToSymbol: function moveToSymbol(cm, head, motionArgs) {
          var repeat = motionArgs.repeat;
          return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
        },
        moveToColumn: function moveToColumn(cm, head, motionArgs, vim) {
          var repeat = motionArgs.repeat;
          vim.lastHPos = repeat - 1;
          vim.lastHSPos = cm.charCoords(head, "div").left;
          return _moveToColumn(cm, repeat);
        },
        moveToEol: function moveToEol(cm, head, motionArgs, vim) {
          return _moveToEol(cm, head, motionArgs, vim, false);
        },
        moveToFirstNonWhiteSpaceCharacter: function moveToFirstNonWhiteSpaceCharacter(cm, head) {
          var cursor = head;
          return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
        },
        moveToMatchedSymbol: function moveToMatchedSymbol(cm, head) {
          var cursor = head;
          var line = cursor.line;
          var ch = cursor.ch;
          var lineText = cm.getLine(line);
          if (ch < lineText.length) {
            var re = ch === "<" || ch === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/;
            var matched = cm.findMatchingBracket(new Pos(line, ch), {
              bracketRegex: re
            });
            return matched.to;
          } else {
            return cursor;
          }
        },
        moveToStartOfLine: function moveToStartOfLine(_cm, head) {
          return new Pos(head.line, 0);
        },
        moveToLineOrEdgeOfDocument: function moveToLineOrEdgeOfDocument(cm, _head, motionArgs) {
          var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
          if (motionArgs.repeatIsExplicit) {
            lineNum = motionArgs.repeat - cm.getOption("firstLineNumber");
          }
          return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
        },
        moveToStartOfDisplayLine: function moveToStartOfDisplayLine(cm) {
          cm.execCommand("goLineLeft");
          return cm.getCursor();
        },
        moveToEndOfDisplayLine: function moveToEndOfDisplayLine(cm) {
          cm.execCommand("goLineRight");
          var head = cm.getCursor();
          if (head.sticky == "before") head.ch--;
          return head;
        },
        textObjectManipulation: function textObjectManipulation(cm, head, motionArgs, vim) {
          var mirroredPairs = {
            "(": ")",
            ")": "(",
            "{": "}",
            "}": "{",
            "[": "]",
            "]": "[",
            "<": ">",
            ">": "<"
          };
          var selfPaired = {
            "'": true,
            '"': true,
            "`": true
          };
          var character = motionArgs.selectedCharacter;
          if (character == "b") {
            character = "(";
          } else if (character == "B") {
            character = "{";
          }
          var inclusive = !motionArgs.textObjectInner;
          var tmp;
          if (mirroredPairs[character]) {
            tmp = selectCompanionObject(cm, head, character, inclusive);
          } else if (selfPaired[character]) {
            tmp = findBeginningAndEnd(cm, head, character, inclusive);
          } else if (character === "W") {
            tmp = expandWordUnderCursor(
              cm,
              inclusive,
              true,
              true
              /** bigWord */
            );
          } else if (character === "w") {
            tmp = expandWordUnderCursor(
              cm,
              inclusive,
              true,
              false
              /** bigWord */
            );
          } else if (character === "p") {
            tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
            motionArgs.linewise = true;
            if (vim.visualMode) {
              if (!vim.visualLine) {
                vim.visualLine = true;
              }
            } else {
              var operatorArgs = vim.inputState.operatorArgs;
              if (operatorArgs) {
                operatorArgs.linewise = true;
              }
              tmp.end.line--;
            }
          } else if (character === "t") {
            tmp = expandTagUnderCursor(cm, head, inclusive);
          } else {
            return null;
          }
          if (!cm.state.vim.visualMode) {
            return [tmp.start, tmp.end];
          } else {
            return expandSelection(cm, tmp.start, tmp.end);
          }
        },
        repeatLastCharacterSearch: function repeatLastCharacterSearch(cm, head, motionArgs) {
          var lastSearch = vimGlobalState.lastCharacterSearch;
          var repeat = motionArgs.repeat;
          var forward = motionArgs.forward === lastSearch.forward;
          var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
          cm.moveH(-increment, "char");
          motionArgs.inclusive = forward ? true : false;
          var curEnd = _moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
          if (!curEnd) {
            cm.moveH(increment, "char");
            return head;
          }
          curEnd.ch += increment;
          return curEnd;
        }
      };
      function defineMotion(name, fn) {
        motions[name] = fn;
      }
      function fillArray(val, times) {
        var arr = [];
        for (var i = 0; i < times; i++) {
          arr.push(val);
        }
        return arr;
      }
      var operators = {
        change: function change(cm, args, ranges) {
          var finalHead, text;
          var vim = cm.state.vim;
          var anchor = ranges[0].anchor, head = ranges[0].head;
          if (!vim.visualMode) {
            text = cm.getRange(anchor, head);
            var lastState = vim.lastEditInputState || {};
            if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
              var match = /\s+$/.exec(text);
              if (match && lastState.motionArgs && lastState.motionArgs.forward) {
                head = offsetCursor(head, 0, -match[0].length);
                text = text.slice(0, -match[0].length);
              }
            }
            var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);
            var wasLastLine = cm.firstLine() == cm.lastLine();
            if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {
              cm.replaceRange("", prevLineEnd, head);
            } else {
              cm.replaceRange("", anchor, head);
            }
            if (args.linewise) {
              if (!wasLastLine) {
                cm.setCursor(prevLineEnd);
                _cm_adapter["default"].commands.newlineAndIndent(cm);
              }
              anchor.ch = Number.MAX_VALUE;
            }
            finalHead = anchor;
          } else if (args.fullLine) {
            head.ch = Number.MAX_VALUE;
            head.line--;
            cm.setSelection(anchor, head);
            text = cm.getSelection();
            cm.replaceSelections("");
            finalHead = anchor;
          } else {
            text = cm.getSelection();
            var replacement = fillArray("", ranges.length);
            cm.replaceSelections(replacement);
            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
          }
          vimGlobalState.registerController.pushText(args.registerName, "change", text, args.linewise, ranges.length > 1);
          actions.enterInsertMode(cm, {
            head: finalHead
          }, cm.state.vim);
        },
        // delete is a javascript keyword.
        "delete": function _delete(cm, args, ranges) {
          cm.pushUndoStop();
          var finalHead, text;
          var vim = cm.state.vim;
          if (!vim.visualBlock) {
            var anchor = ranges[0].anchor, head = ranges[0].head;
            if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {
              if (anchor.line == cm.firstLine()) {
                anchor.ch = 0;
              } else {
                anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
              }
            }
            text = cm.getRange(anchor, head);
            cm.replaceRange("", anchor, head);
            finalHead = anchor;
            if (args.linewise) {
              finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
            }
          } else {
            text = cm.getSelection();
            var replacement = fillArray("", ranges.length);
            cm.replaceSelections(replacement);
            finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
          }
          vimGlobalState.registerController.pushText(args.registerName, "delete", text, args.linewise, vim.visualBlock);
          return clipCursorToContent(cm, finalHead);
        },
        indent: function indent(cm, args, ranges) {
          var vim = cm.state.vim;
          var startLine = ranges[0].anchor.line;
          var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;
          var repeat = vim.visualMode ? args.repeat : 1;
          if (args.linewise) {
            endLine--;
          }
          cm.pushUndoStop();
          for (var i = startLine; i <= endLine; i++) {
            for (var j = 0; j < repeat; j++) {
              cm.indentLine(i, args.indentRight);
            }
          }
          cm.pushUndoStop();
          return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
        },
        indentAuto: function indentAuto(cm, _args, ranges) {
          cm.execCommand("indentAuto");
          return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
        },
        changeCase: function changeCase(cm, args, ranges, oldAnchor, newHead) {
          var selections = cm.getSelections();
          var swapped = [];
          var toLower = args.toLower;
          for (var j = 0; j < selections.length; j++) {
            var toSwap = selections[j];
            var text = "";
            if (toLower === true) {
              text = toSwap.toLowerCase();
            } else if (toLower === false) {
              text = toSwap.toUpperCase();
            } else {
              for (var i = 0; i < toSwap.length; i++) {
                var character = toSwap.charAt(i);
                text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();
              }
            }
            swapped.push(text);
          }
          cm.replaceSelections(swapped);
          if (args.shouldMoveCursor) {
            return newHead;
          } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {
            return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
          } else if (args.linewise) {
            return oldAnchor;
          } else {
            return cursorMin(ranges[0].anchor, ranges[0].head);
          }
        },
        yank: function yank(cm, args, ranges, oldAnchor) {
          var vim = cm.state.vim;
          var text = cm.getSelection();
          var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;
          vimGlobalState.registerController.pushText(args.registerName, "yank", text, args.linewise, vim.visualBlock);
          return endPos;
        }
      };
      function defineOperator(name, fn) {
        operators[name] = fn;
      }
      var actions = {
        jumpListWalk: function jumpListWalk(cm, actionArgs, vim) {
          if (vim.visualMode) {
            return;
          }
          var repeat = actionArgs.repeat;
          var forward = actionArgs.forward;
          var jumpList = vimGlobalState.jumpList;
          var mark = jumpList.move(cm, forward ? repeat : -repeat);
          var markPos = mark ? mark.find() : void 0;
          markPos = markPos ? markPos : cm.getCursor();
          cm.setCursor(markPos);
        },
        scroll: function scroll(cm, actionArgs, vim) {
          if (vim.visualMode) {
            return;
          }
          var repeat = actionArgs.repeat || 1;
          var lineHeight = cm.defaultTextHeight();
          var top = cm.getScrollInfo().top;
          var delta = lineHeight * repeat;
          var newPos = actionArgs.forward ? top + delta : top - delta;
          var cursor = copyCursor(cm.getCursor());
          var cursorCoords = cm.charCoords(cursor, "local");
          if (actionArgs.forward) {
            if (newPos > cursorCoords.top) {
              cursor.line += (newPos - cursorCoords.top) / lineHeight;
              cursor.line = Math.ceil(cursor.line);
              cm.setCursor(cursor);
              cursorCoords = cm.charCoords(cursor, "local");
              cm.scrollTo(null, cursorCoords.top);
            } else {
              cm.scrollTo(null, newPos);
            }
          } else {
            var newBottom = newPos + cm.getScrollInfo().clientHeight;
            if (newBottom < cursorCoords.bottom) {
              cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
              cursor.line = Math.floor(cursor.line);
              cm.setCursor(cursor);
              cursorCoords = cm.charCoords(cursor, "local");
              cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
            } else {
              cm.scrollTo(null, newPos);
            }
          }
        },
        scrollToCursor: function scrollToCursor(cm, actionArgs) {
          var lineNum = cm.getCursor().line;
          var charCoords = cm.charCoords(new Pos(lineNum, 0), "local");
          var height = cm.getScrollInfo().clientHeight;
          var y = charCoords.top;
          var lineHeight = charCoords.bottom - y;
          switch (actionArgs.position) {
            case "center":
              y = y - height / 2 + lineHeight;
              break;
            case "bottom":
              y = y - height + lineHeight;
              break;
          }
          cm.moveCurrentLineTo(y);
        },
        replayMacro: function replayMacro(cm, actionArgs, vim) {
          var registerName = actionArgs.selectedCharacter;
          var repeat = actionArgs.repeat;
          var macroModeState = vimGlobalState.macroModeState;
          if (registerName == "@") {
            registerName = macroModeState.latestRegister;
          } else {
            macroModeState.latestRegister = registerName;
          }
          while (repeat--) {
            executeMacroRegister(cm, vim, macroModeState, registerName);
          }
        },
        enterMacroRecordMode: function enterMacroRecordMode(cm, actionArgs) {
          var macroModeState = vimGlobalState.macroModeState;
          var registerName = actionArgs.selectedCharacter;
          if (vimGlobalState.registerController.isValidRegister(registerName)) {
            macroModeState.enterMacroRecordMode(cm, registerName);
          }
        },
        toggleOverwrite: function toggleOverwrite(cm) {
          if (!cm.state.overwrite) {
            cm.toggleOverwrite(true);
            cm.setOption("keyMap", "vim-replace");
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "replace"
            });
          } else {
            cm.toggleOverwrite(false);
            cm.setOption("keyMap", "vim-insert");
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "insert"
            });
          }
        },
        enterInsertMode: function enterInsertMode(cm, actionArgs, vim) {
          if (cm.getOption("readOnly")) {
            return;
          }
          vim.insertMode = true;
          vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
          var insertAt = actionArgs ? actionArgs.insertAt : null;
          var sel = vim.sel;
          var head = actionArgs.head || cm.getCursor("head");
          var height = cm.listSelections().length;
          if (insertAt == "eol") {
            head = new Pos(head.line, lineLength(cm, head.line));
          } else if (insertAt == "bol") {
            head = new Pos(head.line, 0);
          } else if (insertAt == "charAfter") {
            head = offsetCursor(head, 0, 1);
          } else if (insertAt == "firstNonBlank") {
            head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);
          } else if (insertAt == "startOfSelectedArea") {
            if (!vim.visualMode) return;
            if (!vim.visualBlock) {
              if (sel.head.line < sel.anchor.line) {
                head = sel.head;
              } else {
                head = new Pos(sel.anchor.line, 0);
              }
            } else {
              head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));
              height = Math.abs(sel.head.line - sel.anchor.line) + 1;
            }
          } else if (insertAt == "endOfSelectedArea") {
            if (!vim.visualMode) return;
            if (!vim.visualBlock) {
              if (sel.head.line >= sel.anchor.line) {
                head = offsetCursor(sel.head, 0, 1);
              } else {
                head = new Pos(sel.anchor.line, 0);
              }
            } else {
              head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);
              height = Math.abs(sel.head.line - sel.anchor.line) + 1;
            }
          } else if (insertAt == "inplace") {
            if (vim.visualMode) {
              return;
            }
          } else if (insertAt == "lastEdit") {
            head = getLastEditPos(cm) || head;
          }
          cm.setOption("disableInput", false);
          if (actionArgs && actionArgs.replace) {
            cm.toggleOverwrite(true);
            cm.setOption("keyMap", "vim-replace");
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "replace"
            });
          } else {
            cm.toggleOverwrite(false);
            cm.setOption("keyMap", "vim-insert");
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "insert"
            });
          }
          if (!vimGlobalState.macroModeState.isPlaying) {
            cm.on("change", onChange);
            _cm_adapter["default"].on(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
          }
          if (vim.visualMode) {
            exitVisualMode(cm);
          }
          selectForInsert(cm, head, height);
        },
        toggleVisualMode: function toggleVisualMode(cm, actionArgs, vim) {
          var repeat = actionArgs.repeat;
          var anchor = cm.getCursor();
          var head;
          if (!vim.visualMode) {
            vim.visualMode = true;
            vim.visualLine = !!actionArgs.linewise;
            vim.visualBlock = !!actionArgs.blockwise;
            head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));
            vim.sel = {
              anchor,
              head
            };
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "visual",
              subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""
            });
            updateCmSelection(cm);
            updateMark(cm, vim, "<", cursorMin(anchor, head));
            updateMark(cm, vim, ">", cursorMax(anchor, head));
          } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {
            vim.visualLine = !!actionArgs.linewise;
            vim.visualBlock = !!actionArgs.blockwise;
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "visual",
              subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""
            });
            updateCmSelection(cm);
          } else {
            exitVisualMode(cm);
          }
        },
        reselectLastSelection: function reselectLastSelection(cm, _actionArgs, vim) {
          var lastSelection = vim.lastSelection;
          if (vim.visualMode) {
            updateLastSelection(cm, vim);
          }
          if (lastSelection) {
            var anchor = lastSelection.anchorMark.find();
            var head = lastSelection.headMark.find();
            if (!anchor || !head) {
              return;
            }
            vim.sel = {
              anchor,
              head
            };
            vim.visualMode = true;
            vim.visualLine = lastSelection.visualLine;
            vim.visualBlock = lastSelection.visualBlock;
            updateCmSelection(cm);
            updateMark(cm, vim, "<", cursorMin(anchor, head));
            updateMark(cm, vim, ">", cursorMax(anchor, head));
            _cm_adapter["default"].signal(cm, "vim-mode-change", {
              mode: "visual",
              subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""
            });
          }
        },
        joinLines: function joinLines(cm, actionArgs, vim) {
          var curStart, curEnd;
          if (vim.visualMode) {
            curStart = cm.getCursor("anchor");
            curEnd = cm.getCursor("head");
            if (cursorIsBefore(curEnd, curStart)) {
              var tmp = curEnd;
              curEnd = curStart;
              curStart = tmp;
            }
            curEnd.ch = lineLength(cm, curEnd.line) - 1;
          } else {
            var repeat = Math.max(actionArgs.repeat, 2);
            curStart = cm.getCursor();
            curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));
          }
          var finalCh = 0;
          for (var i = curStart.line; i < curEnd.line; i++) {
            finalCh = lineLength(cm, curStart.line);
            var tmp = new Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));
            var text = cm.getRange(curStart, tmp);
            text = actionArgs.keepSpaces ? text.replace(/\n\r?/g, "") : text.replace(/\n\s*/g, " ");
            cm.replaceRange(text, curStart, tmp);
          }
          var curFinalPos = new Pos(curStart.line, finalCh);
          if (vim.visualMode) {
            exitVisualMode(cm, false);
          }
          cm.setCursor(curFinalPos);
        },
        newLineAndEnterInsertMode: function newLineAndEnterInsertMode(cm, actionArgs, vim) {
          if (cm.getOption("readOnly")) {
            return;
          }
          vim.insertMode = true;
          var insertAt = copyCursor(cm.getCursor());
          if (insertAt.line === cm.firstLine() && !actionArgs.after) {
            cm.replaceRange("\n", new Pos(cm.firstLine(), 0));
            cm.setCursor(cm.firstLine(), 0);
          } else {
            insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;
            insertAt.ch = lineLength(cm, insertAt.line);
            cm.setCursor(insertAt);
            var newlineFn = _cm_adapter["default"].commands.newlineAndIndentContinueComment || _cm_adapter["default"].commands.newlineAndIndent;
            newlineFn(cm);
          }
          this.enterInsertMode(cm, {
            repeat: actionArgs.repeat
          }, vim);
        },
        paste: function paste(cm, actionArgs, vim) {
          var cur = copyCursor(cm.getCursor());
          var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);
          var text = register.toString();
          if (!text) {
            return;
          }
          if (actionArgs.matchIndent) {
            var tabSize = cm.getOption("tabSize");
            var whitespaceLength = function whitespaceLength2(str) {
              var tabs = str.split("	").length - 1;
              var spaces = str.split(" ").length - 1;
              return tabs * tabSize + spaces * 1;
            };
            var currentLine = cm.getLine(cm.getCursor().line);
            var indent = whitespaceLength(currentLine.match(/^\s*/)[0]);
            var chompedText = text.replace(/\n$/, "");
            var wasChomped = text !== chompedText;
            var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
            var text = chompedText.replace(/^\s*/gm, function(wspace) {
              var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
              if (newIndent < 0) {
                return "";
              } else if (cm.getOption("indentWithTabs")) {
                var quotient = Math.floor(newIndent / tabSize);
                return Array(quotient + 1).join("	");
              } else {
                return Array(newIndent + 1).join(" ");
              }
            });
            text += wasChomped ? "\n" : "";
          }
          if (actionArgs.repeat > 1) {
            var text = Array(actionArgs.repeat + 1).join(text);
          }
          var linewise = register.linewise;
          var blockwise = register.blockwise;
          if (blockwise) {
            text = text.split("\n");
            if (linewise) {
              text.pop();
            }
            for (var i = 0; i < text.length; i++) {
              text[i] = text[i] == "" ? " " : text[i];
            }
            cur.ch += actionArgs.after ? 1 : 0;
            cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
          } else if (linewise) {
            if (vim.visualMode) {
              text = vim.visualLine ? text.slice(0, -1) : "\n" + text.slice(0, text.length - 1) + "\n";
            } else if (actionArgs.after) {
              text = "\n" + text.slice(0, text.length - 1);
              cur.ch = lineLength(cm, cur.line);
            } else {
              cur.ch = 0;
            }
          } else {
            cur.ch += actionArgs.after ? 1 : 0;
          }
          var curPosFinal;
          var idx;
          if (vim.visualMode) {
            vim.lastPastedText = text;
            var lastSelectionCurEnd;
            var selectedArea = getSelectedAreaRange(cm, vim);
            var selectionStart = selectedArea[0];
            var selectionEnd = selectedArea[1];
            var selectedText = cm.getSelection();
            var selections = cm.listSelections();
            var emptyStrings = new Array(selections.length).join("1").split("1");
            if (vim.lastSelection) {
              lastSelectionCurEnd = vim.lastSelection.headMark.find();
            }
            vimGlobalState.registerController.unnamedRegister.setText(selectedText);
            if (blockwise) {
              cm.replaceSelections(emptyStrings);
              selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);
              cm.setCursor(selectionStart);
              selectBlock(cm, selectionEnd);
              cm.replaceSelections(text);
              curPosFinal = selectionStart;
            } else if (vim.visualBlock) {
              cm.replaceSelections(emptyStrings);
              cm.setCursor(selectionStart);
              cm.replaceRange(text, selectionStart, selectionStart);
              curPosFinal = selectionStart;
            } else {
              cm.replaceRange(text, selectionStart, selectionEnd);
              curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
            }
            if (lastSelectionCurEnd) {
              vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
            }
            if (linewise) {
              curPosFinal.ch = 0;
            }
          } else {
            if (blockwise) {
              cm.setCursor(cur);
              for (var i = 0; i < text.length; i++) {
                var line = cur.line + i;
                if (line > cm.lastLine()) {
                  cm.replaceRange("\n", new Pos(line, 0));
                }
                var lastCh = lineLength(cm, line);
                if (lastCh < cur.ch) {
                  extendLineToColumn(cm, line, cur.ch);
                }
              }
              cm.setCursor(cur);
              selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));
              cm.replaceSelections(text);
              curPosFinal = cur;
            } else {
              cm.replaceRange(text, cur);
              if (linewise && actionArgs.after) {
                curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
              } else if (linewise && !actionArgs.after) {
                curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
              } else if (!linewise && actionArgs.after) {
                idx = cm.indexFromPos(cur);
                curPosFinal = cm.posFromIndex(idx + text.length - 1);
              } else {
                idx = cm.indexFromPos(cur);
                curPosFinal = cm.posFromIndex(idx + text.length);
              }
            }
          }
          if (vim.visualMode) {
            exitVisualMode(cm, false);
          }
          cm.setCursor(curPosFinal);
        },
        undo: function undo(cm, actionArgs) {
          cm.operation(function() {
            repeatFn(cm, _cm_adapter["default"].commands.undo, actionArgs.repeat)();
            cm.setCursor(cm.getCursor("anchor"));
          });
        },
        redo: function redo(cm, actionArgs) {
          repeatFn(cm, _cm_adapter["default"].commands.redo, actionArgs.repeat)();
        },
        setRegister: function setRegister(_cm, actionArgs, vim) {
          vim.inputState.registerName = actionArgs.selectedCharacter;
        },
        setMark: function setMark(cm, actionArgs, vim) {
          var markName = actionArgs.selectedCharacter;
          updateMark(cm, vim, markName, cm.getCursor());
        },
        replace: function replace(cm, actionArgs, vim) {
          var replaceWith = actionArgs.selectedCharacter;
          var curStart = cm.getCursor();
          var replaceTo;
          var curEnd;
          var selections = cm.listSelections();
          if (vim.visualMode) {
            curStart = cm.getCursor("start");
            curEnd = cm.getCursor("end");
          } else {
            var line = cm.getLine(curStart.line);
            replaceTo = curStart.ch + actionArgs.repeat;
            if (replaceTo > line.length) {
              replaceTo = line.length;
            }
            curEnd = new Pos(curStart.line, replaceTo);
          }
          if (replaceWith == "\n") {
            if (!vim.visualMode) cm.replaceRange("", curStart, curEnd);
            (_cm_adapter["default"].commands.newlineAndIndentContinueComment || _cm_adapter["default"].commands.newlineAndIndent)(cm);
          } else {
            var replaceWithStr = cm.getRange(curStart, curEnd);
            replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
            if (vim.visualBlock) {
              var spaces = new Array(cm.getOption("tabSize") + 1).join(" ");
              replaceWithStr = cm.getSelection();
              replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split("\n");
              cm.replaceSelections(replaceWithStr);
            } else {
              cm.replaceRange(replaceWithStr, curStart, curEnd);
            }
            if (vim.visualMode) {
              curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;
              cm.setCursor(curStart);
              exitVisualMode(cm, false);
            } else {
              cm.setCursor(offsetCursor(curEnd, 0, -1));
            }
          }
        },
        incrementNumberToken: function incrementNumberToken(cm, actionArgs) {
          var cur = cm.getCursor();
          var lineStr = cm.getLine(cur.line);
          var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
          var match;
          var start;
          var end;
          var numberStr;
          while ((match = re.exec(lineStr)) !== null) {
            start = match.index;
            end = start + match[0].length;
            if (cur.ch < end) break;
          }
          if (!actionArgs.backtrack && end <= cur.ch) return;
          if (match) {
            var baseStr = match[2] || match[4];
            var digits = match[3] || match[5];
            var increment = actionArgs.increase ? 1 : -1;
            var base = {
              "0b": 2,
              0: 8,
              "": 10,
              "0x": 16
            }[baseStr.toLowerCase()];
            var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;
            numberStr = number.toString(base);
            var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join("0") : "";
            if (numberStr.charAt(0) === "-") {
              numberStr = "-" + baseStr + zeroPadding + numberStr.substr(1);
            } else {
              numberStr = baseStr + zeroPadding + numberStr;
            }
            var from = new Pos(cur.line, start);
            var to = new Pos(cur.line, end);
            cm.replaceRange(numberStr, from, to);
          } else {
            return;
          }
          cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));
        },
        repeatLastEdit: function repeatLastEdit(cm, actionArgs, vim) {
          var lastEditInputState = vim.lastEditInputState;
          if (!lastEditInputState) {
            return;
          }
          var repeat = actionArgs.repeat;
          if (repeat && actionArgs.repeatIsExplicit) {
            vim.lastEditInputState.repeatOverride = repeat;
          } else {
            repeat = vim.lastEditInputState.repeatOverride || repeat;
          }
          _repeatLastEdit(
            cm,
            vim,
            repeat,
            false
            /** repeatForInsert */
          );
        },
        indent: function indent(cm, actionArgs) {
          cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
        },
        exitInsertMode
      };
      function defineAction(name, fn) {
        actions[name] = fn;
      }
      function clipCursorToContent(cm, cur) {
        var vim = cm.state.vim;
        var includeLineBreak = vim.insertMode || vim.visualMode;
        var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());
        var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;
        var ch = Math.min(Math.max(0, cur.ch), maxCh);
        return new Pos(line, ch);
      }
      function copyArgs(args) {
        var ret = {};
        for (var prop in args) {
          if (args.hasOwnProperty(prop)) {
            ret[prop] = args[prop];
          }
        }
        return ret;
      }
      function offsetCursor(cur, offsetLine, offsetCh) {
        if (_typeof(offsetLine) === "object") {
          offsetCh = offsetLine.ch;
          offsetLine = offsetLine.line;
        }
        return new Pos(cur.line + offsetLine, cur.ch + offsetCh);
      }
      function commandMatches(keys, keyMap, context, inputState) {
        var match, partial = [], full = [];
        for (var i = 0; i < keyMap.length; i++) {
          var command = keyMap[i];
          if (context == "insert" && command.context != "insert" || command.context && command.context != context || inputState.operator && command.type == "action" || !(match = commandMatch(keys, command.keys))) {
            continue;
          }
          if (match == "partial") {
            partial.push(command);
          }
          if (match == "full") {
            full.push(command);
          }
        }
        return {
          partial: partial.length && partial,
          full: full.length && full
        };
      }
      function commandMatch(pressed, mapped) {
        if (mapped.slice(-11) == "<character>") {
          var prefixLen = mapped.length - 11;
          var pressedPrefix = pressed.slice(0, prefixLen);
          var mappedPrefix = mapped.slice(0, prefixLen);
          return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? "full" : mappedPrefix.indexOf(pressedPrefix) == 0 ? "partial" : false;
        } else {
          return pressed == mapped ? "full" : mapped.indexOf(pressed) == 0 ? "partial" : false;
        }
      }
      function lastChar(keys) {
        var match = /^.*(<[^>]+>)$/.exec(keys);
        var selectedCharacter = match ? match[1] : keys.slice(-1);
        if (selectedCharacter.length > 1) {
          switch (selectedCharacter) {
            case "<CR>":
              selectedCharacter = "\n";
              break;
            case "<Space>":
              selectedCharacter = " ";
              break;
            default:
              selectedCharacter = "";
              break;
          }
        }
        return selectedCharacter;
      }
      function repeatFn(cm, fn, repeat) {
        return function() {
          for (var i = 0; i < repeat; i++) {
            fn(cm);
          }
        };
      }
      function copyCursor(cur) {
        return new Pos(cur.line, cur.ch);
      }
      function cursorEqual(cur1, cur2) {
        return cur1.ch == cur2.ch && cur1.line == cur2.line;
      }
      function cursorIsBefore(cur1, cur2) {
        if (cur1.line < cur2.line) {
          return true;
        }
        if (cur1.line == cur2.line && cur1.ch < cur2.ch) {
          return true;
        }
        return false;
      }
      function cursorMin(cur1, cur2) {
        if (arguments.length > 2) {
          cur2 = cursorMin.apply(void 0, Array.prototype.slice.call(arguments, 1));
        }
        return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
      }
      function cursorMax(cur1, cur2) {
        if (arguments.length > 2) {
          cur2 = cursorMax.apply(void 0, Array.prototype.slice.call(arguments, 1));
        }
        return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
      }
      function cursorIsBetween(cur1, cur2, cur3) {
        var cur1before2 = cursorIsBefore(cur1, cur2);
        var cur2before3 = cursorIsBefore(cur2, cur3);
        return cur1before2 && cur2before3;
      }
      function lineLength(cm, lineNum) {
        return cm.getLine(lineNum).length;
      }
      function trim(s) {
        if (s.trim) {
          return s.trim();
        }
        return s.replace(/^\s+|\s+$/g, "");
      }
      function escapeRegex(s) {
        return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
      }
      function extendLineToColumn(cm, lineNum, column) {
        var endCh = lineLength(cm, lineNum);
        var spaces = new Array(column - endCh + 1).join(" ");
        cm.setCursor(new Pos(lineNum, endCh));
        cm.replaceRange(spaces, cm.getCursor());
      }
      function selectBlock(cm, selectionEnd) {
        var selections = [], ranges = cm.listSelections();
        var head = copyCursor(cm.clipPos(selectionEnd));
        var isClipped = !cursorEqual(selectionEnd, head);
        var curHead = cm.getCursor("head");
        var primIndex = getIndex(ranges, curHead);
        var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
        var max = ranges.length - 1;
        var index = max - primIndex > primIndex ? max : 0;
        var base = ranges[index].anchor;
        var firstLine = Math.min(base.line, head.line);
        var lastLine = Math.max(base.line, head.line);
        var baseCh = base.ch, headCh = head.ch;
        var dir = ranges[index].head.ch - baseCh;
        var newDir = headCh - baseCh;
        if (dir > 0 && newDir <= 0) {
          baseCh++;
          if (!isClipped) {
            headCh--;
          }
        } else if (dir < 0 && newDir >= 0) {
          baseCh--;
          if (!wasClipped) {
            headCh++;
          }
        } else if (dir < 0 && newDir == -1) {
          baseCh--;
          headCh++;
        }
        for (var line = firstLine; line <= lastLine; line++) {
          var range = {
            anchor: new Pos(line, baseCh),
            head: new Pos(line, headCh)
          };
          selections.push(range);
        }
        cm.setSelections(selections);
        selectionEnd.ch = headCh;
        base.ch = baseCh;
        return base;
      }
      function selectForInsert(cm, head, height) {
        var sel = [];
        for (var i = 0; i < height; i++) {
          var lineHead = offsetCursor(head, i, 0);
          sel.push({
            anchor: lineHead,
            head: lineHead
          });
        }
        cm.setSelections(sel, 0);
      }
      function getIndex(ranges, cursor, end) {
        for (var i = 0; i < ranges.length; i++) {
          var atAnchor = end != "head" && cursorEqual(ranges[i].anchor, cursor);
          var atHead = end != "anchor" && cursorEqual(ranges[i].head, cursor);
          if (atAnchor || atHead) {
            return i;
          }
        }
        return -1;
      }
      function getSelectedAreaRange(cm, vim) {
        var lastSelection = vim.lastSelection;
        var getCurrentSelectedAreaRange = function getCurrentSelectedAreaRange2() {
          var selections = cm.listSelections();
          var start = selections[0];
          var end = selections[selections.length - 1];
          var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;
          var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;
          return [selectionStart, selectionEnd];
        };
        var getLastSelectedAreaRange = function getLastSelectedAreaRange2() {
          var selectionStart = cm.getCursor();
          var selectionEnd = cm.getCursor();
          var block = lastSelection.visualBlock;
          if (block) {
            var width = block.width;
            var height = block.height;
            selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);
            var selections = [];
            for (var i = selectionStart.line; i < selectionEnd.line; i++) {
              var anchor = new Pos(i, selectionStart.ch);
              var head = new Pos(i, selectionEnd.ch);
              var range = {
                anchor,
                head
              };
              selections.push(range);
            }
            cm.setSelections(selections);
          } else {
            var start = lastSelection.anchorMark.find();
            var end = lastSelection.headMark.find();
            var line = end.line - start.line;
            var ch = end.ch - start.ch;
            selectionEnd = {
              line: selectionEnd.line + line,
              ch: line ? selectionEnd.ch : ch + selectionEnd.ch
            };
            if (lastSelection.visualLine) {
              selectionStart = new Pos(selectionStart.line, 0);
              selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
            }
            cm.setSelection(selectionStart, selectionEnd);
          }
          return [selectionStart, selectionEnd];
        };
        if (!vim.visualMode) {
          return getLastSelectedAreaRange();
        } else {
          return getCurrentSelectedAreaRange();
        }
      }
      function updateLastSelection(cm, vim) {
        var anchor = vim.sel.anchor;
        var head = vim.sel.head;
        if (vim.lastPastedText) {
          head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
          vim.lastPastedText = null;
        }
        vim.lastSelection = {
          anchorMark: cm.setBookmark(anchor),
          headMark: cm.setBookmark(head),
          anchor: copyCursor(anchor),
          head: copyCursor(head),
          visualMode: vim.visualMode,
          visualLine: vim.visualLine,
          visualBlock: vim.visualBlock
        };
      }
      function expandSelection(cm, start, end) {
        var sel = cm.state.vim.sel;
        var head = sel.head;
        var anchor = sel.anchor;
        var tmp;
        if (cursorIsBefore(end, start)) {
          tmp = end;
          end = start;
          start = tmp;
        }
        if (cursorIsBefore(head, anchor)) {
          head = cursorMin(start, head);
          anchor = cursorMax(anchor, end);
        } else {
          anchor = cursorMin(start, anchor);
          head = cursorMax(head, end);
          head = offsetCursor(head, 0, -1);
          if (head.ch == -1 && head.line != cm.firstLine()) {
            head = new Pos(head.line - 1, lineLength(cm, head.line - 1));
          }
        }
        return [anchor, head];
      }
      function updateCmSelection(cm, sel, mode) {
        var vim = cm.state.vim;
        sel = sel || vim.sel;
        var mode = mode || vim.visualLine ? "line" : vim.visualBlock ? "block" : "char";
        var cmSel = makeCmSelection(cm, sel, mode);
        cm.setSelections(cmSel.ranges, cmSel.primary);
      }
      function makeCmSelection(cm, sel, mode, exclusive) {
        var head = copyCursor(sel.head);
        var anchor = copyCursor(sel.anchor);
        if (mode == "char") {
          var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
          var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
          head = offsetCursor(sel.head, 0, headOffset);
          anchor = offsetCursor(sel.anchor, 0, anchorOffset);
          return {
            ranges: [{
              anchor,
              head
            }],
            primary: 0
          };
        } else if (mode == "line") {
          if (!cursorIsBefore(sel.head, sel.anchor)) {
            anchor.ch = 0;
            var lastLine = cm.lastLine();
            if (head.line > lastLine) {
              head.line = lastLine;
            }
            head.ch = lineLength(cm, head.line);
          } else {
            head.ch = 0;
            anchor.ch = lineLength(cm, anchor.line);
          }
          return {
            ranges: [{
              anchor,
              head
            }],
            primary: 0
          };
        } else if (mode == "block") {
          var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;
          if (fromCh < toCh) {
            toCh += 1;
          } else {
            fromCh += 1;
          }
          var height = bottom - top + 1;
          var primary = head.line == top ? 0 : height - 1;
          var ranges = [];
          for (var i = 0; i < height; i++) {
            ranges.push({
              anchor: new Pos(top + i, fromCh),
              head: new Pos(top + i, toCh)
            });
          }
          return {
            ranges,
            primary
          };
        }
      }
      function getHead(cm) {
        var cur = cm.getCursor("head");
        if (cm.getSelection().length == 1) {
          cur = cursorMin(cur, cm.getCursor("anchor"));
        }
        return cur;
      }
      function exitVisualMode(cm, moveHead) {
        var vim = cm.state.vim;
        if (moveHead !== false) {
          cm.setCursor(clipCursorToContent(cm, vim.sel.head));
        }
        updateLastSelection(cm, vim);
        vim.visualMode = false;
        vim.visualLine = false;
        vim.visualBlock = false;
        if (!vim.insertMode) _cm_adapter["default"].signal(cm, "vim-mode-change", {
          mode: "normal"
        });
      }
      function clipToLine(cm, curStart, curEnd) {
        var selection = cm.getRange(curStart, curEnd);
        if (/\n\s*$/.test(selection)) {
          var lines = selection.split("\n");
          lines.pop();
          var line;
          for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
            curEnd.line--;
            curEnd.ch = 0;
          }
          if (line) {
            curEnd.line--;
            curEnd.ch = lineLength(cm, curEnd.line);
          } else {
            curEnd.ch = 0;
          }
        }
      }
      function expandSelectionToLine(_cm, curStart, curEnd) {
        curStart.ch = 0;
        curEnd.ch = 0;
        curEnd.line++;
      }
      function findFirstNonWhiteSpaceCharacter(text) {
        if (!text) {
          return 0;
        }
        var firstNonWS = text.search(/\S/);
        return firstNonWS == -1 ? text.length : firstNonWS;
      }
      function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
        var cur = getHead(cm);
        var line = cm.getLine(cur.line);
        var idx = cur.ch;
        var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];
        while (!test(line.charAt(idx))) {
          idx++;
          if (idx >= line.length) {
            return null;
          }
        }
        if (bigWord) {
          test = bigWordCharTest[0];
        } else {
          test = wordCharTest[0];
          if (!test(line.charAt(idx))) {
            test = wordCharTest[1];
          }
        }
        var end = idx, start = idx;
        while (test(line.charAt(end)) && end < line.length) {
          end++;
        }
        while (test(line.charAt(start)) && start >= 0) {
          start--;
        }
        start++;
        if (inclusive) {
          var wordEnd = end;
          while (/\s/.test(line.charAt(end)) && end < line.length) {
            end++;
          }
          if (wordEnd == end) {
            var wordStart = start;
            while (/\s/.test(line.charAt(start - 1)) && start > 0) {
              start--;
            }
            if (!start) {
              start = wordStart;
            }
          }
        }
        return {
          start: new Pos(cur.line, start),
          end: new Pos(cur.line, end)
        };
      }
      function expandTagUnderCursor(cm, head, inclusive) {
        var cur = head;
        if (!_cm_adapter["default"].findMatchingTag || !_cm_adapter["default"].findEnclosingTag) {
          return {
            start: cur,
            end: cur
          };
        }
        var tags = _cm_adapter["default"].findMatchingTag(cm, head) || _cm_adapter["default"].findEnclosingTag(cm, head);
        if (!tags || !tags.open || !tags.close) {
          return {
            start: cur,
            end: cur
          };
        }
        if (inclusive) {
          return {
            start: tags.open.from,
            end: tags.close.to
          };
        }
        return {
          start: tags.open.to,
          end: tags.close.from
        };
      }
      function recordJumpPosition(cm, oldCur, newCur) {
        if (!cursorEqual(oldCur, newCur)) {
          vimGlobalState.jumpList.add(cm, oldCur, newCur);
        }
      }
      function recordLastCharacterSearch(increment, args) {
        vimGlobalState.lastCharacterSearch.increment = increment;
        vimGlobalState.lastCharacterSearch.forward = args.forward;
        vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
      }
      var symbolToMode = {
        "(": "bracket",
        ")": "bracket",
        "{": "bracket",
        "}": "bracket",
        "[": "section",
        "]": "section",
        "*": "comment",
        "/": "comment",
        m: "method",
        M: "method",
        "#": "preprocess"
      };
      var findSymbolModes = {
        bracket: {
          isComplete: function isComplete(state) {
            if (state.nextCh === state.symb) {
              state.depth++;
              if (state.depth >= 1) return true;
            } else if (state.nextCh === state.reverseSymb) {
              state.depth--;
            }
            return false;
          }
        },
        section: {
          init: function init(state) {
            state.curMoveThrough = true;
            state.symb = (state.forward ? "]" : "[") === state.symb ? "{" : "}";
          },
          isComplete: function isComplete(state) {
            return state.index === 0 && state.nextCh === state.symb;
          }
        },
        comment: {
          isComplete: function isComplete(state) {
            var found = state.lastCh === "*" && state.nextCh === "/";
            state.lastCh = state.nextCh;
            return found;
          }
        },
        // TODO: The original Vim implementation only operates on level 1 and 2.
        // The current implementation doesn't check for code block level and
        // therefore it operates on any levels.
        method: {
          init: function init(state) {
            state.symb = state.symb === "m" ? "{" : "}";
            state.reverseSymb = state.symb === "{" ? "}" : "{";
          },
          isComplete: function isComplete(state) {
            if (state.nextCh === state.symb) return true;
            return false;
          }
        },
        preprocess: {
          init: function init(state) {
            state.index = 0;
          },
          isComplete: function isComplete(state) {
            if (state.nextCh === "#") {
              var token = state.lineText.match(/^#(\w+)/)[1];
              if (token === "endif") {
                if (state.forward && state.depth === 0) {
                  return true;
                }
                state.depth++;
              } else if (token === "if") {
                if (!state.forward && state.depth === 0) {
                  return true;
                }
                state.depth--;
              }
              if (token === "else" && state.depth === 0) return true;
            }
            return false;
          }
        }
      };
      function findSymbol(cm, repeat, forward, symb) {
        var cur = copyCursor(cm.getCursor());
        var increment = forward ? 1 : -1;
        var endLine = forward ? cm.lineCount() : -1;
        var curCh = cur.ch;
        var line = cur.line;
        var lineText = cm.getLine(line);
        var state = {
          lineText,
          nextCh: lineText.charAt(curCh),
          lastCh: null,
          index: curCh,
          symb,
          reverseSymb: (forward ? {
            ")": "(",
            "}": "{"
          } : {
            "(": ")",
            "{": "}"
          })[symb],
          forward,
          depth: 0,
          curMoveThrough: false
        };
        var mode = symbolToMode[symb];
        if (!mode) return cur;
        var init = findSymbolModes[mode].init;
        var isComplete = findSymbolModes[mode].isComplete;
        if (init) {
          init(state);
        }
        while (line !== endLine && repeat) {
          state.index += increment;
          state.nextCh = state.lineText.charAt(state.index);
          if (!state.nextCh) {
            line += increment;
            state.lineText = cm.getLine(line) || "";
            if (increment > 0) {
              state.index = 0;
            } else {
              var lineLen = state.lineText.length;
              state.index = lineLen > 0 ? lineLen - 1 : 0;
            }
            state.nextCh = state.lineText.charAt(state.index);
          }
          if (isComplete(state)) {
            cur.line = line;
            cur.ch = state.index;
            repeat--;
          }
        }
        if (state.nextCh || state.curMoveThrough) {
          return new Pos(line, state.index);
        }
        return cur;
      }
      function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
        var lineNum = cur.line;
        var pos = cur.ch;
        var line = cm.getLine(lineNum);
        var dir = forward ? 1 : -1;
        var charTests = bigWord ? bigWordCharTest : wordCharTest;
        if (emptyLineIsWord && line == "") {
          lineNum += dir;
          line = cm.getLine(lineNum);
          if (!isLine(cm, lineNum)) {
            return null;
          }
          pos = forward ? 0 : line.length;
        }
        while (true) {
          if (emptyLineIsWord && line == "") {
            return {
              from: 0,
              to: 0,
              line: lineNum
            };
          }
          var stop = dir > 0 ? line.length : -1;
          var wordStart = stop, wordEnd = stop;
          while (pos != stop) {
            var foundWord = false;
            for (var i = 0; i < charTests.length && !foundWord; ++i) {
              if (charTests[i](line.charAt(pos))) {
                wordStart = pos;
                while (pos != stop && charTests[i](line.charAt(pos))) {
                  pos += dir;
                }
                wordEnd = pos;
                foundWord = wordStart != wordEnd;
                if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {
                  continue;
                } else {
                  return {
                    from: Math.min(wordStart, wordEnd + 1),
                    to: Math.max(wordStart, wordEnd),
                    line: lineNum
                  };
                }
              }
            }
            if (!foundWord) {
              pos += dir;
            }
          }
          lineNum += dir;
          if (!isLine(cm, lineNum)) {
            return null;
          }
          line = cm.getLine(lineNum);
          pos = dir > 0 ? 0 : line.length;
        }
      }
      function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
        var curStart = copyCursor(cur);
        var words = [];
        if (forward && !wordEnd || !forward && wordEnd) {
          repeat++;
        }
        var emptyLineIsWord = !(forward && wordEnd);
        for (var i = 0; i < repeat; i++) {
          var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
          if (!word) {
            var eodCh = lineLength(cm, cm.lastLine());
            words.push(forward ? {
              line: cm.lastLine(),
              from: eodCh,
              to: eodCh
            } : {
              line: 0,
              from: 0,
              to: 0
            });
            break;
          }
          words.push(word);
          cur = new Pos(word.line, forward ? word.to - 1 : word.from);
        }
        var shortCircuit = words.length != repeat;
        var firstWord = words[0];
        var lastWord = words.pop();
        if (forward && !wordEnd) {
          if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {
            lastWord = words.pop();
          }
          return new Pos(lastWord.line, lastWord.from);
        } else if (forward && wordEnd) {
          return new Pos(lastWord.line, lastWord.to - 1);
        } else if (!forward && wordEnd) {
          if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {
            lastWord = words.pop();
          }
          return new Pos(lastWord.line, lastWord.to);
        } else {
          return new Pos(lastWord.line, lastWord.from);
        }
      }
      function _moveToEol(cm, head, motionArgs, vim, keepHPos) {
        var cur = head;
        var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);
        var end = cm.clipPos(retval);
        end.ch--;
        if (!keepHPos) {
          vim.lastHPos = Infinity;
          vim.lastHSPos = cm.charCoords(end, "div").left;
        }
        return retval;
      }
      function _moveToCharacter(cm, repeat, forward, character) {
        var cur = cm.getCursor();
        var start = cur.ch;
        var idx;
        for (var i = 0; i < repeat; i++) {
          var line = cm.getLine(cur.line);
          idx = charIdxInLine(start, line, character, forward, true);
          if (idx == -1) {
            return null;
          }
          start = idx;
        }
        return new Pos(cm.getCursor().line, idx);
      }
      function _moveToColumn(cm, repeat) {
        var line = cm.getCursor().line;
        return clipCursorToContent(cm, new Pos(line, repeat - 1));
      }
      function updateMark(cm, vim, markName, pos) {
        if (!inArray(markName, validMarks)) {
          return;
        }
        if (vim.marks[markName]) {
          vim.marks[markName].clear();
        }
        vim.marks[markName] = cm.setBookmark(pos);
      }
      function charIdxInLine(start, line, character, forward, includeChar) {
        var idx;
        if (forward) {
          idx = line.indexOf(character, start + 1);
          if (idx != -1 && !includeChar) {
            idx -= 1;
          }
        } else {
          idx = line.lastIndexOf(character, start - 1);
          if (idx != -1 && !includeChar) {
            idx += 1;
          }
        }
        return idx;
      }
      function findParagraph(cm, head, repeat, dir, inclusive) {
        var line = head.line;
        var min = cm.firstLine();
        var max = cm.lastLine();
        var start, end, i = line;
        function isEmpty(i2) {
          return !cm.getLine(i2);
        }
        function isBoundary(i2, dir2, any) {
          if (any) {
            return isEmpty(i2) != isEmpty(i2 + dir2);
          }
          return !isEmpty(i2) && isEmpty(i2 + dir2);
        }
        if (dir) {
          while (min <= i && i <= max && repeat > 0) {
            if (isBoundary(i, dir)) {
              repeat--;
            }
            i += dir;
          }
          return new Pos(i, 0);
        }
        var vim = cm.state.vim;
        if (vim.visualLine && isBoundary(line, 1, true)) {
          var anchor = vim.sel.anchor;
          if (isBoundary(anchor.line, -1, true)) {
            if (!inclusive || anchor.line != line) {
              line += 1;
            }
          }
        }
        var startState = isEmpty(line);
        for (i = line; i <= max && repeat; i++) {
          if (isBoundary(i, 1, true)) {
            if (!inclusive || isEmpty(i) != startState) {
              repeat--;
            }
          }
        }
        end = new Pos(i, 0);
        if (i > max && !startState) {
          startState = true;
        } else {
          inclusive = false;
        }
        for (i = line; i > min; i--) {
          if (!inclusive || isEmpty(i) == startState || i == line) {
            if (isBoundary(i, -1, true)) {
              break;
            }
          }
        }
        start = new Pos(i, 0);
        return {
          start,
          end
        };
      }
      function findSentence(cm, cur, repeat, dir) {
        function nextChar(cm2, idx) {
          if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
            idx.ln += idx.dir;
            if (!isLine(cm2, idx.ln)) {
              idx.line = null;
              idx.ln = null;
              idx.pos = null;
              return;
            }
            idx.line = cm2.getLine(idx.ln);
            idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;
          } else {
            idx.pos += idx.dir;
          }
        }
        function forward(cm2, ln, pos, dir2) {
          var line = cm2.getLine(ln);
          var stop = line === "";
          var curr = {
            line,
            ln,
            pos,
            dir: dir2
          };
          var last_valid = {
            ln: curr.ln,
            pos: curr.pos
          };
          var skip_empty_lines = curr.line === "";
          nextChar(cm2, curr);
          while (curr.line !== null) {
            last_valid.ln = curr.ln;
            last_valid.pos = curr.pos;
            if (curr.line === "" && !skip_empty_lines) {
              return {
                ln: curr.ln,
                pos: curr.pos
              };
            } else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
              return {
                ln: curr.ln,
                pos: curr.pos
              };
            } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {
              stop = true;
            }
            nextChar(cm2, curr);
          }
          var line = cm2.getLine(last_valid.ln);
          last_valid.pos = 0;
          for (var i = line.length - 1; i >= 0; --i) {
            if (!isWhiteSpaceString(line[i])) {
              last_valid.pos = i;
              break;
            }
          }
          return last_valid;
        }
        function reverse(cm2, ln, pos, dir2) {
          var line = cm2.getLine(ln);
          var curr = {
            line,
            ln,
            pos,
            dir: dir2
          };
          var last_valid = {
            ln: curr.ln,
            pos: null
          };
          var skip_empty_lines = curr.line === "";
          nextChar(cm2, curr);
          while (curr.line !== null) {
            if (curr.line === "" && !skip_empty_lines) {
              if (last_valid.pos !== null) {
                return last_valid;
              } else {
                return {
                  ln: curr.ln,
                  pos: curr.pos
                };
              }
            } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {
              return last_valid;
            } else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
              skip_empty_lines = false;
              last_valid = {
                ln: curr.ln,
                pos: curr.pos
              };
            }
            nextChar(cm2, curr);
          }
          var line = cm2.getLine(last_valid.ln);
          last_valid.pos = 0;
          for (var i = 0; i < line.length; ++i) {
            if (!isWhiteSpaceString(line[i])) {
              last_valid.pos = i;
              break;
            }
          }
          return last_valid;
        }
        var curr_index = {
          ln: cur.line,
          pos: cur.ch
        };
        while (repeat > 0) {
          if (dir < 0) {
            curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
          } else {
            curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
          }
          repeat--;
        }
        return new Pos(curr_index.ln, curr_index.pos);
      }
      function selectCompanionObject(cm, head, symb, inclusive) {
        var cur = head, start, end;
        var bracketRegexp = {
          "(": /[()]/,
          ")": /[()]/,
          "[": /[[\]]/,
          "]": /[[\]]/,
          "{": /[{}]/,
          "}": /[{}]/,
          "<": /[<>]/,
          ">": /[<>]/
        }[symb];
        var openSym = {
          "(": "(",
          ")": "(",
          "[": "[",
          "]": "[",
          "{": "{",
          "}": "{",
          "<": "<",
          ">": "<"
        }[symb];
        var curChar = cm.getLine(cur.line).charAt(cur.ch);
        var offset = curChar === openSym ? 1 : 0;
        start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, void 0, {
          bracketRegex: bracketRegexp
        });
        end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, void 0, {
          bracketRegex: bracketRegexp
        });
        if (!start || !end) {
          return {
            start: cur,
            end: cur
          };
        }
        start = start.pos;
        end = end.pos;
        if (start.line == end.line && start.ch > end.ch || start.line > end.line) {
          var tmp = start;
          start = end;
          end = tmp;
        }
        if (inclusive) {
          end.ch += 1;
        } else {
          start.ch += 1;
        }
        return {
          start,
          end
        };
      }
      function findBeginningAndEnd(cm, head, symb, inclusive) {
        var cur = copyCursor(head);
        var line = cm.getLine(cur.line);
        var chars = line.split("");
        var start, end, i, len;
        var firstIndex = chars.indexOf(symb);
        if (cur.ch < firstIndex) {
          cur.ch = firstIndex;
        } else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
          end = cur.ch;
          --cur.ch;
        }
        if (chars[cur.ch] == symb && !end) {
          start = cur.ch + 1;
        } else {
          for (i = cur.ch; i > -1 && !start; i--) {
            if (chars[i] == symb) {
              start = i + 1;
            }
          }
        }
        if (start && !end) {
          for (i = start, len = chars.length; i < len && !end; i++) {
            if (chars[i] == symb) {
              end = i;
            }
          }
        }
        if (!start || !end) {
          return {
            start: cur,
            end: cur
          };
        }
        if (inclusive) {
          --start;
          ++end;
        }
        return {
          start: new Pos(cur.line, start),
          end: new Pos(cur.line, end)
        };
      }
      defineOption("pcre", true, "boolean");
      function SearchState() {
      }
      SearchState.prototype = {
        getQuery: function getQuery() {
          return vimGlobalState.query;
        },
        setQuery: function setQuery(query) {
          vimGlobalState.query = query;
        },
        getOverlay: function getOverlay() {
          return this.searchOverlay;
        },
        setOverlay: function setOverlay(overlay) {
          this.searchOverlay = overlay;
        },
        isReversed: function isReversed() {
          return vimGlobalState.isReversed;
        },
        setReversed: function setReversed(reversed) {
          vimGlobalState.isReversed = reversed;
        },
        getScrollbarAnnotate: function getScrollbarAnnotate() {
          return this.annotate;
        },
        setScrollbarAnnotate: function setScrollbarAnnotate(annotate) {
          this.annotate = annotate;
        }
      };
      function getSearchState(cm) {
        var vim = cm.state.vim;
        return vim.searchState_ || (vim.searchState_ = new SearchState());
      }
      function splitBySlash(argString) {
        return splitBySeparator(argString, "/");
      }
      function findUnescapedSlashes(argString) {
        return findUnescapedSeparators(argString, "/");
      }
      function splitBySeparator(argString, separator) {
        var slashes = findUnescapedSeparators(argString, separator) || [];
        if (!slashes.length) return [];
        var tokens = [];
        if (slashes[0] !== 0) return;
        for (var i = 0; i < slashes.length; i++) {
          if (typeof slashes[i] == "number") tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));
        }
        return tokens;
      }
      function findUnescapedSeparators(str, separator) {
        if (!separator) separator = "/";
        var escapeNextChar = false;
        var slashes = [];
        for (var i = 0; i < str.length; i++) {
          var c = str.charAt(i);
          if (!escapeNextChar && c == separator) {
            slashes.push(i);
          }
          escapeNextChar = !escapeNextChar && c == "\\";
        }
        return slashes;
      }
      function translateRegex(str) {
        var specials = "|(){";
        var unescape = "}";
        var escapeNextChar = false;
        var out = [];
        for (var i = -1; i < str.length; i++) {
          var c = str.charAt(i) || "";
          var n = str.charAt(i + 1) || "";
          var specialComesNext = n && specials.indexOf(n) != -1;
          if (escapeNextChar) {
            if (c !== "\\" || !specialComesNext) {
              out.push(c);
            }
            escapeNextChar = false;
          } else {
            if (c === "\\") {
              escapeNextChar = true;
              if (n && unescape.indexOf(n) != -1) {
                specialComesNext = true;
              }
              if (!specialComesNext || n === "\\") {
                out.push(c);
              }
            } else {
              out.push(c);
              if (specialComesNext && n !== "\\") {
                out.push("\\");
              }
            }
          }
        }
        return out.join("");
      }
      var charUnescapes = {
        "\\n": "\n",
        "\\r": "\r",
        "\\t": "	"
      };
      function translateRegexReplace(str) {
        var escapeNextChar = false;
        var out = [];
        for (var i = -1; i < str.length; i++) {
          var c = str.charAt(i) || "";
          var n = str.charAt(i + 1) || "";
          if (charUnescapes[c + n]) {
            out.push(charUnescapes[c + n]);
            i++;
          } else if (escapeNextChar) {
            out.push(c);
            escapeNextChar = false;
          } else {
            if (c === "\\") {
              escapeNextChar = true;
              if (isNumber(n) || n === "$") {
                out.push("$");
              } else if (n !== "/" && n !== "\\") {
                out.push("\\");
              }
            } else {
              if (c === "$") {
                out.push("$");
              }
              out.push(c);
              if (n === "/") {
                out.push("\\");
              }
            }
          }
        }
        return out.join("");
      }
      var unescapes = {
        "\\/": "/",
        "\\\\": "\\",
        "\\n": "\n",
        "\\r": "\r",
        "\\t": "	",
        "\\&": "&"
      };
      function unescapeRegexReplace(str) {
        var stream = new _cm_adapter["default"].StringStream(str);
        var output = [];
        while (!stream.eol()) {
          while (stream.peek() && stream.peek() != "\\") {
            output.push(stream.next());
          }
          var matched = false;
          for (var matcher in unescapes) {
            if (stream.match(matcher, true)) {
              matched = true;
              output.push(unescapes[matcher]);
              break;
            }
          }
          if (!matched) {
            output.push(stream.next());
          }
        }
        return output.join("");
      }
      function parseQuery(query, ignoreCase, smartCase) {
        var lastSearchRegister = vimGlobalState.registerController.getRegister("/");
        lastSearchRegister.setText(query);
        if (query instanceof RegExp) {
          return query;
        }
        var slashes = findUnescapedSlashes(query);
        var regexPart;
        var forceIgnoreCase;
        if (!slashes.length) {
          regexPart = query;
        } else {
          regexPart = query.substring(0, slashes[0]);
          var flagsPart = query.substring(slashes[0]);
          forceIgnoreCase = flagsPart.indexOf("i") != -1;
        }
        if (!regexPart) {
          return null;
        }
        if (!getOption("pcre")) {
          regexPart = translateRegex(regexPart);
        }
        if (smartCase) {
          ignoreCase = /^[^A-Z]*$/.test(regexPart);
        }
        var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? "im" : "m");
        return regexp;
      }
      function dom(n) {
        if (typeof n === "string") n = document.createElement(n);
        for (var a, i = 1; i < arguments.length; i++) {
          if (!(a = arguments[i])) continue;
          if (_typeof(a) !== "object") a = document.createTextNode(a);
          if (a.nodeType) n.appendChild(a);
          else for (var key in a) {
            if (!Object.prototype.hasOwnProperty.call(a, key)) continue;
            if (key[0] === "$") n.style[key.slice(1)] = a[key];
            else n.setAttribute(key, a[key]);
          }
        }
        return n;
      }
      function showConfirm(cm, template) {
        var pre = dom("pre", {
          $color: "red",
          "class": "cm-vim-message"
        }, template);
        if (cm.openNotification) {
          cm.openNotification(pre, {
            bottom: true,
            duration: 5e3
          });
        } else {
          alert(pre.innerText);
        }
      }
      function makePrompt(prefix, desc) {
        return dom(document.createDocumentFragment(), dom("span", {
          $fontFamily: "monospace",
          $whiteSpace: "pre"
        }, prefix, dom("input", {
          type: "text",
          autocorrect: "off",
          autocapitalize: "off",
          spellcheck: "false"
        })), desc && dom("span", {
          $color: "#888"
        }, desc));
      }
      function showPrompt(cm, options2) {
        var template = makePrompt(options2.prefix, options2.desc);
        if (cm.openDialog) {
          cm.openDialog(template, options2.onClose, {
            onKeyDown: options2.onKeyDown,
            onKeyUp: options2.onKeyUp,
            bottom: true,
            selectValueOnOpen: false,
            value: options2.value
          });
        } else {
          var shortText = "";
          if (typeof options2.prefix != "string" && options2.prefix) shortText += options2.prefix.textContent;
          if (options2.desc) shortText += " " + options2.desc;
          options2.onClose(prompt(shortText, ""));
        }
      }
      function regexEqual(r1, r2) {
        if (r1 instanceof RegExp && r2 instanceof RegExp) {
          var props = ["global", "multiline", "ignoreCase", "source"];
          for (var i = 0; i < props.length; i++) {
            var prop = props[i];
            if (r1[prop] !== r2[prop]) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
        if (!rawQuery) {
          return;
        }
        var state = getSearchState(cm);
        var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
        if (!query) {
          return;
        }
        highlightSearchMatches(cm, query);
        if (regexEqual(query, state.getQuery())) {
          return query;
        }
        state.setQuery(query);
        return query;
      }
      function searchOverlay(query) {
        if (query.source.charAt(0) == "^") {
          var matchSol = true;
        }
        return {
          token: function token(stream) {
            if (matchSol && !stream.sol()) {
              stream.skipToEnd();
              return;
            }
            var match = stream.match(query, false);
            if (match) {
              if (match[0].length == 0) {
                stream.next();
                return "searching";
              }
              if (!stream.sol()) {
                stream.backUp(1);
                if (!query.exec(stream.next() + match[0])) {
                  stream.next();
                  return null;
                }
              }
              stream.match(query);
              return "searching";
            }
            while (!stream.eol()) {
              stream.next();
              if (stream.match(query, false)) break;
            }
          },
          query
        };
      }
      var highlightTimeout = 0;
      function highlightSearchMatches(cm, query) {
        clearTimeout(highlightTimeout);
        highlightTimeout = setTimeout(function() {
          if (!cm.state.vim) return;
          var searchState = getSearchState(cm);
          var overlay = searchState.getOverlay();
          if (!overlay || query != overlay.query) {
            if (overlay) {
              cm.removeOverlay(overlay);
            }
            overlay = searchOverlay(query);
            cm.addOverlay(overlay);
            if (cm.showMatchesOnScrollbar) {
              if (searchState.getScrollbarAnnotate()) {
                searchState.getScrollbarAnnotate().clear();
              }
              searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
            }
            searchState.setOverlay(overlay);
          }
        }, 50);
      }
      function _findNext(cm, prev, query, repeat) {
        if (repeat === void 0) {
          repeat = 1;
        }
        return cm.operation(function() {
          var pos = cm.getCursor();
          var cursor = cm.getSearchCursor(query, pos);
          for (var i = 0; i < repeat; i++) {
            var found = cursor.find(prev);
            if (i == 0 && found && cursorEqual(cursor.from(), pos)) {
              var lastEndPos = prev ? cursor.from() : cursor.to();
              found = cursor.find(prev);
              if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {
                if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);
              }
            }
            if (!found) {
              cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
              if (!cursor.find(prev)) {
                return;
              }
            }
          }
          return cursor.from();
        });
      }
      function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {
        if (repeat === void 0) {
          repeat = 1;
        }
        return cm.operation(function() {
          var pos = cm.getCursor();
          var cursor = cm.getSearchCursor(query, pos);
          var found = cursor.find(!prev);
          if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {
            cursor.find(!prev);
          }
          for (var i = 0; i < repeat; i++) {
            found = cursor.find(prev);
            if (!found) {
              cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
              if (!cursor.find(prev)) {
                return;
              }
            }
          }
          return [cursor.from(), cursor.to()];
        });
      }
      function clearSearchHighlight(cm) {
        var state = getSearchState(cm);
        cm.removeOverlay(getSearchState(cm).getOverlay());
        state.setOverlay(null);
        if (state.getScrollbarAnnotate()) {
          state.getScrollbarAnnotate().clear();
          state.setScrollbarAnnotate(null);
        }
      }
      function isInRange(pos, start, end) {
        if (typeof pos != "number") {
          pos = pos.line;
        }
        if (start instanceof Array) {
          return inArray(pos, start);
        } else {
          if (typeof end == "number") {
            return pos >= start && pos <= end;
          } else {
            return pos == start;
          }
        }
      }
      function getUserVisibleLines(cm) {
        var scrollInfo = cm.getScrollInfo();
        var occludeToleranceTop = 6;
        var occludeToleranceBottom = 10;
        var from = cm.coordsChar({
          left: 0,
          top: occludeToleranceTop + scrollInfo.top
        }, "local");
        var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
        var to = cm.coordsChar({
          left: 0,
          top: bottomY
        }, "local");
        return {
          top: from.line,
          bottom: to.line
        };
      }
      function getMarkPos(cm, vim, markName) {
        if (markName == "'" || markName == "`") {
          return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);
        } else if (markName == ".") {
          return getLastEditPos(cm);
        }
        var mark = vim.marks[markName];
        return mark && mark.find();
      }
      function getLastEditPos(cm) {
        var done = cm.doc.history.done;
        for (var i = done.length; i--; ) {
          if (done[i].changes) {
            return copyCursor(done[i].changes[0].to);
          }
        }
      }
      var ExCommandDispatcher = function ExCommandDispatcher2() {
        this.buildCommandMap_();
      };
      ExCommandDispatcher.prototype = {
        processCommand: function processCommand(cm, input, opt_params) {
          var that = this;
          cm.operation(function() {
            cm.curOp.isVimOp = true;
            that._processCommand(cm, input, opt_params);
          });
        },
        _processCommand: function _processCommand(cm, input, opt_params) {
          var vim = cm.state.vim;
          var commandHistoryRegister = vimGlobalState.registerController.getRegister(":");
          var previousCommand = commandHistoryRegister.toString();
          if (vim.visualMode) {
            exitVisualMode(cm);
          }
          var inputStream = new _cm_adapter["default"].StringStream(input);
          commandHistoryRegister.setText(input);
          var params = opt_params || {};
          params.input = input;
          try {
            this.parseInput_(cm, inputStream, params);
          } catch (e) {
            showConfirm(cm, e.toString());
            throw e;
          }
          var command;
          var commandName;
          if (!params.commandName) {
            if (params.line !== void 0) {
              commandName = "move";
            }
          } else {
            command = this.matchCommand_(params.commandName);
            if (command) {
              commandName = command.name;
              if (command.excludeFromCommandHistory) {
                commandHistoryRegister.setText(previousCommand);
              }
              this.parseCommandArgs_(inputStream, params, command);
              if (command.type == "exToKey") {
                for (var i = 0; i < command.toKeys.length; i++) {
                  vimApi.handleKey(cm, command.toKeys[i], "mapping");
                }
                return;
              } else if (command.type == "exToEx") {
                this.processCommand(cm, command.toInput);
                return;
              }
            }
          }
          if (!commandName) {
            showConfirm(cm, 'Not an editor command ":' + input + '"');
            return;
          }
          try {
            exCommands[commandName](cm, params);
            if ((!command || !command.possiblyAsync) && params.callback) {
              params.callback();
            }
          } catch (e) {
            showConfirm(cm, e.toString());
            throw e;
          }
        },
        parseInput_: function parseInput_(cm, inputStream, result) {
          inputStream.eatWhile(":");
          if (inputStream.eat("%")) {
            result.line = cm.firstLine();
            result.lineEnd = cm.lastLine();
          } else {
            result.line = this.parseLineSpec_(cm, inputStream);
            if (result.line !== void 0 && inputStream.eat(",")) {
              result.lineEnd = this.parseLineSpec_(cm, inputStream);
            }
          }
          var commandMatch2 = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
          if (commandMatch2) {
            result.commandName = commandMatch2[1];
          } else {
            result.commandName = inputStream.match(/.*/)[0];
          }
          return result;
        },
        parseLineSpec_: function parseLineSpec_(cm, inputStream) {
          var numberMatch = inputStream.match(/^(\d+)/);
          if (numberMatch) {
            return parseInt(numberMatch[1], 10) - 1;
          }
          switch (inputStream.next()) {
            case ".":
              return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
            case "$":
              return this.parseLineSpecOffset_(inputStream, cm.lastLine());
            case "'":
              var markName = inputStream.next();
              var markPos = getMarkPos(cm, cm.state.vim, markName);
              if (!markPos) throw new Error("Mark not set");
              return this.parseLineSpecOffset_(inputStream, markPos.line);
            case "-":
            case "+":
              inputStream.backUp(1);
              return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
            default:
              inputStream.backUp(1);
              return void 0;
          }
        },
        parseLineSpecOffset_: function parseLineSpecOffset_(inputStream, line) {
          var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
          if (offsetMatch) {
            var offset = parseInt(offsetMatch[2], 10);
            if (offsetMatch[1] == "-") {
              line -= offset;
            } else {
              line += offset;
            }
          }
          return line;
        },
        parseCommandArgs_: function parseCommandArgs_(inputStream, params, command) {
          if (inputStream.eol()) {
            return;
          }
          params.argString = inputStream.match(/.*/)[0];
          var delim = command.argDelimiter || /\s+/;
          var args = trim(params.argString).split(delim);
          if (args.length && args[0]) {
            params.args = args;
          }
        },
        matchCommand_: function matchCommand_(commandName) {
          for (var i = commandName.length; i > 0; i--) {
            var prefix = commandName.substring(0, i);
            if (this.commandMap_[prefix]) {
              var command = this.commandMap_[prefix];
              if (command.name.indexOf(commandName) === 0) {
                return command;
              }
            }
          }
          return null;
        },
        buildCommandMap_: function buildCommandMap_() {
          this.commandMap_ = {};
          for (var i = 0; i < defaultExCommandMap.length; i++) {
            var command = defaultExCommandMap[i];
            var key = command.shortName || command.name;
            this.commandMap_[key] = command;
          }
        },
        map: function map(lhs, rhs, ctx) {
          if (lhs != ":" && lhs.charAt(0) == ":") {
            if (ctx) {
              throw Error("Mode not supported for ex mappings");
            }
            var commandName = lhs.substring(1);
            if (rhs != ":" && rhs.charAt(0) == ":") {
              this.commandMap_[commandName] = {
                name: commandName,
                type: "exToEx",
                toInput: rhs.substring(1),
                user: true
              };
            } else {
              this.commandMap_[commandName] = {
                name: commandName,
                type: "exToKey",
                toKeys: rhs,
                user: true
              };
            }
          } else {
            if (rhs != ":" && rhs.charAt(0) == ":") {
              var mapping = {
                keys: lhs,
                type: "keyToEx",
                exArgs: {
                  input: rhs.substring(1)
                }
              };
              if (ctx) {
                mapping.context = ctx;
              }
              defaultKeymap.unshift(mapping);
            } else {
              var mapping = {
                keys: lhs,
                type: "keyToKey",
                toKeys: rhs
              };
              if (ctx) {
                mapping.context = ctx;
              }
              defaultKeymap.unshift(mapping);
            }
          }
        },
        unmap: function unmap(lhs, ctx) {
          if (lhs != ":" && lhs.charAt(0) == ":") {
            if (ctx) {
              throw Error("Mode not supported for ex mappings");
            }
            var commandName = lhs.substring(1);
            if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
              delete this.commandMap_[commandName];
              return true;
            }
          } else {
            var keys = lhs;
            for (var i = 0; i < defaultKeymap.length; i++) {
              if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {
                defaultKeymap.splice(i, 1);
                return true;
              }
            }
          }
        }
      };
      var exCommands = {
        colorscheme: function colorscheme(cm, params) {
          if (!params.args || params.args.length < 1) {
            showConfirm(cm, cm.getOption("theme"));
            return;
          }
          cm.setOption("theme", params.args[0]);
        },
        map: function map(cm, params, ctx) {
          var mapArgs = params.args;
          if (!mapArgs || mapArgs.length < 2) {
            if (cm) {
              showConfirm(cm, "Invalid mapping: " + params.input);
            }
            return;
          }
          exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
        },
        imap: function imap(cm, params) {
          this.map(cm, params, "insert");
        },
        nmap: function nmap(cm, params) {
          this.map(cm, params, "normal");
        },
        vmap: function vmap(cm, params) {
          this.map(cm, params, "visual");
        },
        unmap: function unmap(cm, params, ctx) {
          var mapArgs = params.args;
          if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {
            if (cm) {
              showConfirm(cm, "No such mapping: " + params.input);
            }
          }
        },
        move: function move(cm, params) {
          commandDispatcher.processCommand(cm, cm.state.vim, {
            type: "motion",
            motion: "moveToLineOrEdgeOfDocument",
            motionArgs: {
              forward: false,
              explicitRepeat: true,
              linewise: true
            },
            repeatOverride: params.line + 1
          });
        },
        set: function set(cm, params) {
          var setArgs = params.args;
          var setCfg = params.setCfg || {};
          if (!setArgs || setArgs.length < 1) {
            if (cm) {
              showConfirm(cm, "Invalid mapping: " + params.input);
            }
            return;
          }
          var expr = setArgs[0].split("=");
          var optionName = expr[0];
          var value = expr[1];
          var forceGet = false;
          if (optionName.charAt(optionName.length - 1) == "?") {
            if (value) {
              throw Error("Trailing characters: " + params.argString);
            }
            optionName = optionName.substring(0, optionName.length - 1);
            forceGet = true;
          }
          if (value === void 0 && optionName.substring(0, 2) == "no") {
            optionName = optionName.substring(2);
            value = false;
          }
          var optionIsBoolean = options[optionName] && options[optionName].type == "boolean";
          if (optionIsBoolean && value == void 0) {
            value = true;
          }
          if (!optionIsBoolean && value === void 0 || forceGet) {
            var oldValue = getOption(optionName, cm, setCfg);
            if (oldValue instanceof Error) {
              showConfirm(cm, oldValue.message);
            } else if (oldValue === true || oldValue === false) {
              showConfirm(cm, " " + (oldValue ? "" : "no") + optionName);
            } else {
              showConfirm(cm, "  " + optionName + "=" + oldValue);
            }
          } else {
            var setOptionReturn = setOption(optionName, value, cm, setCfg);
            if (setOptionReturn instanceof Error) {
              showConfirm(cm, setOptionReturn.message);
            }
          }
        },
        setlocal: function setlocal(cm, params) {
          params.setCfg = {
            scope: "local"
          };
          this.set(cm, params);
        },
        setglobal: function setglobal(cm, params) {
          params.setCfg = {
            scope: "global"
          };
          this.set(cm, params);
        },
        registers: function registers(cm, params) {
          var regArgs = params.args;
          var registers2 = vimGlobalState.registerController.registers;
          var regInfo = "----------Registers----------\n\n";
          if (!regArgs) {
            for (var registerName in registers2) {
              var text = registers2[registerName].toString();
              if (text.length) {
                regInfo += '"' + registerName + "    " + text + "\n";
              }
            }
          } else {
            var registerName;
            regArgs = regArgs.join("");
            for (var i = 0; i < regArgs.length; i++) {
              registerName = regArgs.charAt(i);
              if (!vimGlobalState.registerController.isValidRegister(registerName)) {
                continue;
              }
              var register = registers2[registerName] || new Register();
              regInfo += '"' + registerName + "    " + register.toString() + "\n";
            }
          }
          showConfirm(cm, regInfo);
        },
        sort: function sort(cm, params) {
          var reverse, ignoreCase, unique, number, pattern;
          function parseArgs() {
            if (params.argString) {
              var args = new _cm_adapter["default"].StringStream(params.argString);
              if (args.eat("!")) {
                reverse = true;
              }
              if (args.eol()) {
                return;
              }
              if (!args.eatSpace()) {
                return "Invalid arguments";
              }
              var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
              if (!opts && !args.eol()) {
                return "Invalid arguments";
              }
              if (opts[1]) {
                ignoreCase = opts[1].indexOf("i") != -1;
                unique = opts[1].indexOf("u") != -1;
                var decimal = opts[1].indexOf("d") != -1 || opts[1].indexOf("n") != -1 && 1;
                var hex = opts[1].indexOf("x") != -1 && 1;
                var octal = opts[1].indexOf("o") != -1 && 1;
                if (decimal + hex + octal > 1) {
                  return "Invalid arguments";
                }
                number = decimal && "decimal" || hex && "hex" || octal && "octal";
              }
              if (opts[2]) {
                pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? "i" : "");
              }
            }
          }
          var err = parseArgs();
          if (err) {
            showConfirm(cm, err + ": " + params.argString);
            return;
          }
          var lineStart = params.line || cm.firstLine();
          var lineEnd = params.lineEnd || params.line || cm.lastLine();
          if (lineStart == lineEnd) {
            return;
          }
          var curStart = new Pos(lineStart, 0);
          var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));
          var text = cm.getRange(curStart, curEnd).split("\n");
          var numberRegex2 = pattern ? pattern : number == "decimal" ? /(-?)([\d]+)/ : number == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : number == "octal" ? /([0-7]+)/ : null;
          var radix = number == "decimal" ? 10 : number == "hex" ? 16 : number == "octal" ? 8 : null;
          var numPart = [], textPart = [];
          if (number || pattern) {
            for (var i = 0; i < text.length; i++) {
              var matchPart = pattern ? text[i].match(pattern) : null;
              if (matchPart && matchPart[0] != "") {
                numPart.push(matchPart);
              } else if (!pattern && numberRegex2.exec(text[i])) {
                numPart.push(text[i]);
              } else {
                textPart.push(text[i]);
              }
            }
          } else {
            textPart = text;
          }
          function compareFn(a, b) {
            if (reverse) {
              var tmp;
              tmp = a;
              a = b;
              b = tmp;
            }
            if (ignoreCase) {
              a = a.toLowerCase();
              b = b.toLowerCase();
            }
            var anum = number && numberRegex2.exec(a);
            var bnum = number && numberRegex2.exec(b);
            if (!anum) {
              return a < b ? -1 : 1;
            }
            anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
            bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
            return anum - bnum;
          }
          function comparePatternFn(a, b) {
            if (reverse) {
              var tmp;
              tmp = a;
              a = b;
              b = tmp;
            }
            if (ignoreCase) {
              a[0] = a[0].toLowerCase();
              b[0] = b[0].toLowerCase();
            }
            return a[0] < b[0] ? -1 : 1;
          }
          numPart.sort(pattern ? comparePatternFn : compareFn);
          if (pattern) {
            for (var i = 0; i < numPart.length; i++) {
              numPart[i] = numPart[i].input;
            }
          } else if (!number) {
            textPart.sort(compareFn);
          }
          text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);
          if (unique) {
            var textOld = text;
            var lastLine;
            text = [];
            for (var i = 0; i < textOld.length; i++) {
              if (textOld[i] != lastLine) {
                text.push(textOld[i]);
              }
              lastLine = textOld[i];
            }
          }
          cm.replaceRange(text.join("\n"), curStart, curEnd);
        },
        vglobal: function vglobal(cm, params) {
          this.global(cm, params);
        },
        global: function global(cm, params) {
          var argString = params.argString;
          if (!argString) {
            showConfirm(cm, "Regular Expression missing from global");
            return;
          }
          var inverted = params.commandName[0] === "v";
          var lineStart = params.line !== void 0 ? params.line : cm.firstLine();
          var lineEnd = params.lineEnd || params.line || cm.lastLine();
          var tokens = splitBySlash(argString);
          var regexPart = argString, cmd;
          if (tokens.length) {
            regexPart = tokens[0];
            cmd = tokens.slice(1, tokens.length).join("/");
          }
          if (regexPart) {
            try {
              updateSearchQuery(
                cm,
                regexPart,
                true,
                true
                /** smartCase */
              );
            } catch (e) {
              showConfirm(cm, "Invalid regex: " + regexPart);
              return;
            }
          }
          var query = getSearchState(cm).getQuery();
          var matchedLines = [];
          for (var i = lineStart; i <= lineEnd; i++) {
            var line = cm.getLineHandle(i);
            var matched = query.test(line.text);
            if (matched !== inverted) {
              matchedLines.push(cmd ? line : line.text);
            }
          }
          if (!cmd) {
            showConfirm(cm, matchedLines.join("\n"));
            return;
          }
          var index = 0;
          var _nextCommand = function nextCommand() {
            if (index < matchedLines.length) {
              var line2 = matchedLines[index++];
              var lineNum = cm.getLineNumber(line2);
              if (lineNum == null) {
                _nextCommand();
                return;
              }
              var command = lineNum + 1 + cmd;
              exCommandDispatcher.processCommand(cm, command, {
                callback: _nextCommand
              });
            }
          };
          _nextCommand();
        },
        substitute: function substitute(cm, params) {
          if (!cm.getSearchCursor) {
            throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
          }
          var argString = params.argString;
          var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
          var regexPart, replacePart = "", trailing, flagsPart, count;
          var confirm = false;
          var global = false;
          if (tokens.length) {
            regexPart = tokens[0];
            if (getOption("pcre") && regexPart !== "") {
              regexPart = new RegExp(regexPart).source;
            }
            replacePart = tokens[1];
            if (replacePart !== void 0) {
              if (getOption("pcre")) {
                replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g, "$1$$&"));
              } else {
                replacePart = translateRegexReplace(replacePart);
              }
              vimGlobalState.lastSubstituteReplacePart = replacePart;
            }
            trailing = tokens[2] ? tokens[2].split(" ") : [];
          } else {
            if (argString && argString.length) {
              showConfirm(cm, "Substitutions should be of the form :s/pattern/replace/");
              return;
            }
          }
          if (trailing) {
            flagsPart = trailing[0];
            count = parseInt(trailing[1]);
            if (flagsPart) {
              if (flagsPart.indexOf("c") != -1) {
                confirm = true;
              }
              if (flagsPart.indexOf("g") != -1) {
                global = true;
              }
              if (getOption("pcre")) {
                regexPart = regexPart + "/" + flagsPart;
              } else {
                regexPart = regexPart.replace(/\//g, "\\/") + "/" + flagsPart;
              }
            }
          }
          if (regexPart) {
            try {
              updateSearchQuery(
                cm,
                regexPart,
                true,
                true
                /** smartCase */
              );
            } catch (e) {
              showConfirm(cm, "Invalid regex: " + regexPart);
              return;
            }
          }
          replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
          if (replacePart === void 0) {
            showConfirm(cm, "No previous substitute regular expression");
            return;
          }
          var state = getSearchState(cm);
          var query = state.getQuery();
          var lineStart = params.line !== void 0 ? params.line : cm.getCursor().line;
          var lineEnd = params.lineEnd || lineStart;
          if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {
            lineEnd = Infinity;
          }
          if (count) {
            lineStart = lineEnd;
            lineEnd = lineStart + count - 1;
          }
          var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));
          var cursor = cm.getSearchCursor(query, startPos);
          cm.pushUndoStop();
          doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);
        },
        redo: _cm_adapter["default"].commands.redo,
        undo: _cm_adapter["default"].commands.undo,
        write: function write(cm) {
          if (_cm_adapter["default"].commands.save) {
            _cm_adapter["default"].commands.save(cm);
          } else if (cm.save) {
            cm.save();
          }
        },
        nohlsearch: function nohlsearch(cm) {
          clearSearchHighlight(cm);
        },
        yank: function yank(cm) {
          var cur = copyCursor(cm.getCursor());
          var line = cur.line;
          var lineText = cm.getLine(line);
          vimGlobalState.registerController.pushText("0", "yank", lineText, true, true);
        },
        delmarks: function delmarks(cm, params) {
          if (!params.argString || !trim(params.argString)) {
            showConfirm(cm, "Argument required");
            return;
          }
          var state = cm.state.vim;
          var stream = new _cm_adapter["default"].StringStream(trim(params.argString));
          while (!stream.eol()) {
            stream.eatSpace();
            var count = stream.pos;
            if (!stream.match(/[a-zA-Z]/, false)) {
              showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
              return;
            }
            var sym = stream.next();
            if (stream.match("-", true)) {
              if (!stream.match(/[a-zA-Z]/, false)) {
                showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
                return;
              }
              var startMark = sym;
              var finishMark = stream.next();
              if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {
                var start = startMark.charCodeAt(0);
                var finish = finishMark.charCodeAt(0);
                if (start >= finish) {
                  showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
                  return;
                }
                for (var j = 0; j <= finish - start; j++) {
                  var mark = String.fromCharCode(start + j);
                  delete state.marks[mark];
                }
              } else {
                showConfirm(cm, "Invalid argument: " + startMark + "-");
                return;
              }
            } else {
              delete state.marks[sym];
            }
          }
        }
      };
      var exCommandDispatcher = new ExCommandDispatcher();
      function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {
        cm.state.vim.exMode = true;
        var done = false;
        var lastPos, modifiedLineNumber, joined;
        function replaceAll() {
          cm.operation(function() {
            while (!done) {
              replace();
              next();
            }
            stop();
          });
        }
        function replace() {
          var text = cm.getRange(searchCursor.from(), searchCursor.to());
          var newText = text.replace(query, replaceWith);
          var unmodifiedLineNumber = searchCursor.to().line;
          searchCursor.replace(newText);
          modifiedLineNumber = searchCursor.to().line;
          lineEnd += modifiedLineNumber - unmodifiedLineNumber;
          joined = modifiedLineNumber < unmodifiedLineNumber;
        }
        function findNextValidMatch() {
          var lastMatchTo = lastPos && copyCursor(searchCursor.to());
          var match = searchCursor.findNext();
          if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) {
            match = searchCursor.findNext();
          }
          return match;
        }
        function next() {
          while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {
            if (!global && searchCursor.from().line == modifiedLineNumber && !joined) {
              continue;
            }
            cm.scrollIntoView(searchCursor.from(), 30);
            cm.setSelection(searchCursor.from(), searchCursor.to());
            lastPos = searchCursor.from();
            done = false;
            return;
          }
          done = true;
        }
        function stop(close) {
          if (close) {
            close();
          }
          cm.focus();
          if (lastPos) {
            cm.setCursor(lastPos);
            var vim = cm.state.vim;
            vim.exMode = false;
            vim.lastHPos = vim.lastHSPos = lastPos.ch;
          }
          if (callback) {
            callback();
          }
        }
        function onPromptKeyDown(e, _value, close) {
          _cm_adapter["default"].e_stop(e);
          var keyName = _cm_adapter["default"].keyName(e);
          switch (keyName) {
            case "Y":
              replace();
              next();
              break;
            case "N":
              next();
              break;
            case "A":
              var savedCallback = callback;
              callback = void 0;
              cm.operation(replaceAll);
              callback = savedCallback;
              break;
            case "L":
              replace();
            case "Q":
            case "Esc":
            case "Ctrl-C":
            case "Ctrl-[":
              stop(close);
              break;
          }
          if (done) {
            stop(close);
          }
          return true;
        }
        next();
        if (done) {
          showConfirm(cm, "No matches for " + query.source);
          return;
        }
        if (!confirm) {
          replaceAll();
          if (callback) {
            callback();
          }
          return;
        }
        showPrompt(cm, {
          prefix: dom("span", "replace with ", dom("strong", replaceWith), " (y/n/a/q/l)"),
          onKeyDown: onPromptKeyDown
        });
      }
      _cm_adapter["default"].keyMap.vim = {
        attach: attachVimMap,
        detach: detachVimMap,
        call: cmKey
      };
      function exitInsertMode(cm) {
        var vim = cm.state.vim;
        var macroModeState = vimGlobalState.macroModeState;
        var insertModeChangeRegister = vimGlobalState.registerController.getRegister(".");
        var isPlaying = macroModeState.isPlaying;
        var lastChange = macroModeState.lastInsertModeChanges;
        if (!isPlaying) {
          cm.off("change", onChange);
          _cm_adapter["default"].off(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
        }
        if (!isPlaying && vim.insertModeRepeat > 1) {
          _repeatLastEdit(
            cm,
            vim,
            vim.insertModeRepeat - 1,
            true
            /** repeatForInsert */
          );
          vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
        }
        delete vim.insertModeRepeat;
        vim.insertMode = false;
        cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);
        cm.setOption("keyMap", "vim");
        cm.setOption("disableInput", true);
        cm.toggleOverwrite(false);
        insertModeChangeRegister.setText(lastChange.changes.join(""));
        _cm_adapter["default"].signal(cm, "vim-mode-change", {
          mode: "normal"
        });
        if (macroModeState.isRecording) {
          logInsertModeChange(macroModeState);
        }
        cm.enterVimMode();
      }
      function _mapCommand(command) {
        defaultKeymap.unshift(command);
      }
      function mapCommand(keys, type, name, args, extra) {
        var command = {
          keys,
          type
        };
        command[type] = name;
        command[type + "Args"] = args;
        for (var key in extra) command[key] = extra[key];
        _mapCommand(command);
      }
      defineOption("insertModeEscKeysTimeout", 200, "number");
      _cm_adapter["default"].keyMap["vim-insert"] = {
        // TODO: override navigation keys so that Esc will cancel automatic
        // indentation from o, O, i_<CR>
        fallthrough: ["default"],
        attach: attachVimMap,
        detach: detachVimMap,
        call: cmKey
      };
      _cm_adapter["default"].keyMap["vim-replace"] = {
        Backspace: "goCharLeft",
        fallthrough: ["vim-insert"],
        attach: attachVimMap,
        detach: detachVimMap,
        call: cmKey
      };
      function executeMacroRegister(cm, vim, macroModeState, registerName) {
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (registerName == ":") {
          if (register.keyBuffer[0]) {
            exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
          }
          macroModeState.isPlaying = false;
          return;
        }
        var keyBuffer = register.keyBuffer;
        var imc = 0;
        macroModeState.isPlaying = true;
        macroModeState.replaySearchQueries = register.searchQueries.slice(0);
        for (var i = 0; i < keyBuffer.length; i++) {
          var text = keyBuffer[i];
          var match, key;
          while (text) {
            match = /<\w+-.+?>|<\w+>|./.exec(text);
            key = match[0];
            text = text.substring(match.index + key.length);
            vimApi.handleKey(cm, key, "macro");
            if (vim.insertMode) {
              var changes = register.insertModeChanges[imc++].changes;
              vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;
              repeatInsertModeChanges(cm, changes, 1);
              exitInsertMode(cm);
            }
          }
        }
        macroModeState.isPlaying = false;
      }
      function logKey(macroModeState, key) {
        if (macroModeState.isPlaying) {
          return;
        }
        var registerName = macroModeState.latestRegister;
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register) {
          register.pushText(key);
        }
      }
      function logInsertModeChange(macroModeState) {
        if (macroModeState.isPlaying) {
          return;
        }
        var registerName = macroModeState.latestRegister;
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register && register.pushInsertModeChanges) {
          register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
        }
      }
      function logSearchQuery(macroModeState, query) {
        if (macroModeState.isPlaying) {
          return;
        }
        var registerName = macroModeState.latestRegister;
        var register = vimGlobalState.registerController.getRegister(registerName);
        if (register && register.pushSearchQuery) {
          register.pushSearchQuery(query);
        }
      }
      function onChange(cm, changeObj) {
        var macroModeState = vimGlobalState.macroModeState;
        var lastChange = macroModeState.lastInsertModeChanges;
        if (!macroModeState.isPlaying) {
          while (changeObj) {
            lastChange.expectCursorActivityForChange = true;
            if (lastChange.ignoreCount > 1) {
              lastChange.ignoreCount--;
            } else if (changeObj.origin == "+input" || changeObj.origin == "paste" || changeObj.origin === void 0) {
              var selectionCount = cm.listSelections().length;
              if (selectionCount > 1) lastChange.ignoreCount = selectionCount;
              var text = changeObj.text.join("\n");
              if (lastChange.maybeReset) {
                lastChange.changes = [];
                lastChange.maybeReset = false;
              }
              if (text) {
                if (cm.state.overwrite && !/\n/.test(text)) {
                  lastChange.changes.push([text]);
                } else {
                  lastChange.changes.push(text);
                }
              }
            }
            changeObj = changeObj.next;
          }
        }
      }
      function onCursorActivity(cm) {
        var vim = cm.state.vim;
        if (vim.insertMode) {
          var macroModeState = vimGlobalState.macroModeState;
          if (macroModeState.isPlaying) {
            return;
          }
          var lastChange = macroModeState.lastInsertModeChanges;
          if (lastChange.expectCursorActivityForChange) {
            lastChange.expectCursorActivityForChange = false;
          } else {
            lastChange.maybeReset = true;
          }
        } else if (!cm.curOp.isVimOp) {
          handleExternalSelection(cm, vim);
        }
      }
      function handleExternalSelection(cm, vim) {
        var anchor = cm.getCursor("anchor");
        var head = cm.getCursor("head");
        if (vim.visualMode && !cm.somethingSelected()) {
          exitVisualMode(cm, false);
        } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {
          vim.visualMode = true;
          vim.visualLine = false;
          _cm_adapter["default"].signal(cm, "vim-mode-change", {
            mode: "visual"
          });
        }
        if (vim.visualMode) {
          var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
          var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
          head = offsetCursor(head, 0, headOffset);
          anchor = offsetCursor(anchor, 0, anchorOffset);
          vim.sel = {
            anchor,
            head
          };
          updateMark(cm, vim, "<", cursorMin(head, anchor));
          updateMark(cm, vim, ">", cursorMax(head, anchor));
        } else if (!vim.insertMode) {
          vim.lastHPos = cm.getCursor().ch;
        }
      }
      function InsertModeKey(keyName) {
        this.keyName = keyName;
      }
      function onKeyEventTargetKeyDown(e) {
        var macroModeState = vimGlobalState.macroModeState;
        var lastChange = macroModeState.lastInsertModeChanges;
        var keyName = _cm_adapter["default"].keyName(e);
        if (!keyName) {
          return;
        }
        function onKeyFound() {
          if (lastChange.maybeReset) {
            lastChange.changes = [];
            lastChange.maybeReset = false;
          }
          lastChange.changes.push(new InsertModeKey(keyName));
          return true;
        }
        if (keyName.indexOf("Delete") != -1 || keyName.indexOf("Backspace") != -1) {
          _cm_adapter["default"].lookupKey(keyName, "vim-insert", onKeyFound);
        }
      }
      function _repeatLastEdit(cm, vim, repeat, repeatForInsert) {
        var macroModeState = vimGlobalState.macroModeState;
        macroModeState.isPlaying = true;
        var isAction = !!vim.lastEditActionCommand;
        var cachedInputState = vim.inputState;
        function repeatCommand() {
          if (isAction) {
            commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
          } else {
            commandDispatcher.evalInput(cm, vim);
          }
        }
        function repeatInsert(repeat2) {
          if (macroModeState.lastInsertModeChanges.changes.length > 0) {
            repeat2 = !vim.lastEditActionCommand ? 1 : repeat2;
            var changeObject = macroModeState.lastInsertModeChanges;
            repeatInsertModeChanges(cm, changeObject.changes, repeat2);
          }
        }
        vim.inputState = vim.lastEditInputState;
        if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {
          for (var i = 0; i < repeat; i++) {
            repeatCommand();
            repeatInsert(1);
          }
        } else {
          if (!repeatForInsert) {
            repeatCommand();
          }
          repeatInsert(repeat);
        }
        vim.inputState = cachedInputState;
        if (vim.insertMode && !repeatForInsert) {
          exitInsertMode(cm);
        }
        macroModeState.isPlaying = false;
      }
      function repeatInsertModeChanges(cm, changes, repeat) {
        function keyHandler(binding) {
          if (typeof binding == "string") {
            _cm_adapter["default"].commands[binding](cm);
          } else {
            binding(cm);
          }
          return true;
        }
        var head = cm.getCursor("head");
        var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
        if (visualBlock) {
          selectForInsert(cm, head, visualBlock + 1);
          repeat = cm.listSelections().length;
          cm.setCursor(head);
        }
        for (var i = 0; i < repeat; i++) {
          if (visualBlock) {
            cm.setCursor(offsetCursor(head, i, 0));
          }
          for (var j = 0; j < changes.length; j++) {
            var change = changes[j];
            if (change instanceof InsertModeKey) {
              _cm_adapter["default"].lookupKey(change.keyName, "vim-insert", keyHandler);
            } else if (typeof change == "string") {
              window.cm = cm;
              cm.replaceSelections(change);
            } else {
              var start = cm.getCursor();
              var end = offsetCursor(start, 0, change[0].length);
              cm.replaceRange(change[0], start, end);
              cm.setCursor(end);
            }
          }
        }
        if (visualBlock) {
          cm.setCursor(offsetCursor(head, 0, 1));
        }
      }
      resetVimGlobalState();
      return vimApi;
    };
    _cm_adapter["default"].Vim = Vim();
    var _default = exports["default"] = _cm_adapter["default"];
  }
});

// node_modules/monaco-vim/lib/statusbar.js
var require_statusbar = __commonJS({
  "node_modules/monaco-vim/lib/statusbar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var VimStatusBar = exports["default"] = function() {
      function VimStatusBar2(node, editor) {
        var _this = this;
        var sanitizer = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        _classCallCheck(this, VimStatusBar2);
        this.closeInput = function() {
          _this.removeInputListeners();
          _this.input = null;
          _this.setSec("");
          if (_this.editor) {
            _this.editor.focus();
          }
        };
        this.clear = function() {
          _this.setInnerHtml_(_this.node, "");
        };
        this.inputKeyUp = function(e) {
          var options = _this.input.options;
          if (options && options.onKeyUp) {
            options.onKeyUp(e, e.target.value, _this.closeInput);
          }
        };
        this.inputKeyInput = function(e) {
          var options = _this.input.options;
          if (options && options.onKeyInput) {
            options.onKeyUp(e, e.target.value, _this.closeInput);
          }
        };
        this.inputBlur = function() {
          var options = _this.input.options;
          if (options.closeOnBlur) {
            _this.closeInput();
          }
        };
        this.inputKeyDown = function(e) {
          var _this$input = _this.input, options = _this$input.options, callback = _this$input.callback;
          if (options && options.onKeyDown && options.onKeyDown(e, e.target.value, _this.closeInput)) {
            return;
          }
          if (e.keyCode === 27 || options && options.closeOnEnter !== false && e.keyCode == 13) {
            _this.input.node.blur();
            e.stopPropagation();
            _this.closeInput();
          }
          if (e.keyCode === 13 && callback) {
            e.stopPropagation();
            e.preventDefault();
            callback(e.target.value);
          }
        };
        this.node = node;
        this.modeInfoNode = document.createElement("span");
        this.secInfoNode = document.createElement("span");
        this.notifNode = document.createElement("span");
        this.notifNode.className = "vim-notification";
        this.keyInfoNode = document.createElement("span");
        this.keyInfoNode.setAttribute("style", "float: right");
        this.node.appendChild(this.modeInfoNode);
        this.node.appendChild(this.secInfoNode);
        this.node.appendChild(this.notifNode);
        this.node.appendChild(this.keyInfoNode);
        this.toggleVisibility(false);
        this.editor = editor;
        this.sanitizer = sanitizer;
      }
      return _createClass(VimStatusBar2, [{
        key: "setMode",
        value: function setMode(ev) {
          if (ev.mode === "visual") {
            if (ev.subMode === "linewise") {
              this.setText("--VISUAL LINE--");
            } else if (ev.subMode === "blockwise") {
              this.setText("--VISUAL BLOCK--");
            } else {
              this.setText("--VISUAL--");
            }
            return;
          }
          this.setText("--".concat(ev.mode.toUpperCase(), "--"));
        }
      }, {
        key: "setKeyBuffer",
        value: function setKeyBuffer(key) {
          this.keyInfoNode.textContent = key;
        }
      }, {
        key: "setSec",
        value: function setSec(text, callback, options) {
          this.notifNode.textContent = "";
          if (text === void 0) {
            return this.closeInput;
          }
          this.setInnerHtml_(this.secInfoNode, text);
          var input = this.secInfoNode.querySelector("input");
          if (input) {
            input.focus();
            this.input = {
              callback,
              options,
              node: input
            };
            if (options) {
              if (options.selectValueOnOpen) {
                input.select();
              }
              if (options.value) {
                input.value = options.value;
              }
            }
            this.addInputListeners();
          }
          return this.closeInput;
        }
      }, {
        key: "setText",
        value: function setText(text) {
          this.modeInfoNode.textContent = text;
        }
      }, {
        key: "toggleVisibility",
        value: function toggleVisibility(toggle) {
          if (toggle) {
            this.node.style.display = "block";
          } else {
            this.node.style.display = "none";
          }
          if (this.input) {
            this.removeInputListeners();
          }
          clearInterval(this.notifTimeout);
        }
      }, {
        key: "addInputListeners",
        value: function addInputListeners() {
          var node = this.input.node;
          node.addEventListener("keyup", this.inputKeyUp);
          node.addEventListener("keydown", this.inputKeyDown);
          node.addEventListener("input", this.inputKeyInput);
          node.addEventListener("blur", this.inputBlur);
        }
      }, {
        key: "removeInputListeners",
        value: function removeInputListeners() {
          if (!this.input || !this.input.node) {
            return;
          }
          var node = this.input.node;
          node.removeEventListener("keyup", this.inputKeyUp);
          node.removeEventListener("keydown", this.inputKeyDown);
          node.removeEventListener("input", this.inputKeyInput);
          node.removeEventListener("blur", this.inputBlur);
        }
      }, {
        key: "showNotification",
        value: function showNotification(text) {
          var _this2 = this;
          var sp = document.createElement("span");
          this.setInnerHtml_(sp, text);
          this.notifNode.textContent = sp.textContent;
          this.notifTimeout = setTimeout(function() {
            _this2.notifNode.textContent = "";
          }, 5e3);
        }
      }, {
        key: "setInnerHtml_",
        value: function setInnerHtml_(element, htmlContents) {
          while (element.childNodes.length) {
            element.removeChild(element.childNodes[0]);
          }
          if (!htmlContents) {
            return;
          }
          if (this.sanitizer) {
            element.appendChild(this.sanitizer(htmlContents));
          } else {
            element.appendChild(htmlContents);
          }
        }
      }]);
    }();
  }
});

// node_modules/monaco-vim/lib/index.js
var require_lib = __commonJS({
  "node_modules/monaco-vim/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "StatusBar", {
      enumerable: true,
      get: function get() {
        return _statusbar["default"];
      }
    });
    Object.defineProperty(exports, "VimMode", {
      enumerable: true,
      get: function get() {
        return _keymap_vim["default"];
      }
    });
    exports.initVimMode = initVimMode;
    var _keymap_vim = _interopRequireDefault(require_keymap_vim());
    var _statusbar = _interopRequireDefault(require_statusbar());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function initVimMode(editor) {
      var statusbarNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var StatusBarClass = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _statusbar["default"];
      var sanitizer = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      var vimAdapter = new _keymap_vim["default"](editor);
      if (!statusbarNode) {
        vimAdapter.attach();
        return vimAdapter;
      }
      var statusBar = new StatusBarClass(statusbarNode, editor, sanitizer);
      var keyBuffer = "";
      vimAdapter.on("vim-mode-change", function(mode) {
        statusBar.setMode(mode);
      });
      vimAdapter.on("vim-keypress", function(key) {
        if (key === ":") {
          keyBuffer = "";
        } else {
          keyBuffer += key;
        }
        statusBar.setKeyBuffer(keyBuffer);
      });
      vimAdapter.on("vim-command-done", function() {
        keyBuffer = "";
        statusBar.setKeyBuffer(keyBuffer);
      });
      vimAdapter.on("dispose", function() {
        statusBar.toggleVisibility(false);
        statusBar.closeInput();
        statusBar.clear();
      });
      statusBar.toggleVisibility(true);
      vimAdapter.setStatusBar(statusBar);
      vimAdapter.attach();
      return vimAdapter;
    }
  }
});
export default require_lib();
//# sourceMappingURL=monaco-vim.js.map
